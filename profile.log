FUNCTION  <SNR>171_get_sources_list()
Called 6 times
Total time:   0.000814
 Self time:   0.000814

count  total (s)   self (s)
    6              0.000011   let filetypes_dict = {}
   18              0.000025   for filetype in a:context.filetypes
   12              0.000025     let filetypes_dict[filetype] = 1
   12              0.000009   endfor
                            
    6              0.000721   return values(filter(copy(s:buffer_sources), "has_key(filetypes_dict, v:val.filetype) || has_key(filetypes_dict, '_') || bufnr('%') == v:key || (bufname('%') ==# '[Command Line]' && bufwinnr('#') == v:key)"))

FUNCTION  355()
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000021     return filter( map(copy(a:list), 'get(a:checkers_map, v:val, {})'), '!empty(v:val)' )

FUNCTION  8()
Called 1 time
Total time:   0.000067
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000003     let prependCWD = 0
    1   0.000022   0.000006     if nerdtree#runningWindows()
                                    let prependCWD = a:str !~# '^.:\(\\\|\/\)' && a:str !~# '^\(\\\\\|\/\/\)'
                                else
    1              0.000021         let prependCWD = a:str !~# '^/'
    1              0.000001     endif
                            
    1              0.000002     let toReturn = a:str
    1              0.000001     if prependCWD
                                    let toReturn = getcwd() . s:Path.Slash() . a:str
                                endif
                            
    1              0.000001     return toReturn

FUNCTION  <SNR>145_encode_list()
Called 3 times
Total time:   0.000308
 Self time:   0.000177

count  total (s)   self (s)
                              " End Of Value
    3              0.000005   let EOV = "\xFF"
                              " EOV, encoded size0, data0, EOV, encoded size1, data1, EOV, ...
    3   0.000297   0.000166   return empty(a:arr) ? '' : (EOV . join(map(copy(a:arr), 's:encode_size(strlen(v:val)) . v:val'), EOV) . EOV)

FUNCTION  airline#extensions#whitespace#check()
Called 70 times
Total time:   0.002774
 Self time:   0.002540

count  total (s)   self (s)
   70              0.000259   if &readonly || !&modifiable || !s:enabled || line('$') > s:max_lines
                                return ''
                              endif
                            
   70              0.000191   if !exists('b:airline_whitespace_check')
    2              0.000007     let b:airline_whitespace_check = ''
    2              0.000007     let checks = get(g:, 'airline#extensions#whitespace#checks', s:default_checks)
                            
    2              0.000002     let trailing = 0
    2              0.000004     if index(checks, 'trailing') > -1
    2              0.000120       let trailing = search('\s$', 'nw')
    2              0.000001     endif
                            
    2              0.000002     let mixed = 0
    2              0.000003     if index(checks, 'indent') > -1
    2   0.000245   0.000011       let mixed = s:check_mixed_indent()
    2              0.000002     endif
                            
    2              0.000003     if trailing != 0 || mixed != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if s:show_message
                                    if trailing != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:trailing_format, trailing)
                                    endif
                                    if mixed != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:mixed_indent_format, mixed)
                                    endif
                                  endif
                                endif
    2              0.000000   endif
   70              0.000096   return b:airline_whitespace_check

FUNCTION  syntastic#log#debug()
Called 24 times
Total time:   0.000186
 Self time:   0.000124

count  total (s)   self (s)
   24   0.000156   0.000094     if !s:_isDebugEnabled(a:level)
   24              0.000017         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0 > 0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  gitgutter#utility#highlight_name_for_change()
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000005   if a:text ==# 'added'
    1              0.000001     return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
    1              0.000001     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              endif

FUNCTION  gitgutter#utility#command_in_directory_of_file()
Called 3 times
Total time:   0.000073
 Self time:   0.000032

count  total (s)   self (s)
    3   0.000071   0.000030   return 'cd '.gitgutter#utility#shellescape(gitgutter#utility#directory_of_file()) . (s:fish ? '; and ' : ' && ') . a:cmd

FUNCTION  gitgutter#process_buffer()
Called 4 times
Total time:   0.124910
 Self time:   0.000485

count  total (s)   self (s)
    4   0.000145   0.000023   call gitgutter#utility#set_buffer(a:bufnr)
    4   0.000350   0.000022   if gitgutter#utility#is_active()
    3              0.000004     if g:gitgutter_sign_column_always
                                  call gitgutter#sign#add_dummy_sign()
                                endif
    3              0.000003     try
    3   0.000014   0.000011       if !a:realtime || gitgutter#utility#has_fresh_changes()
    3   0.102882   0.000110         let diff = gitgutter#diff#run_diff(a:realtime || gitgutter#utility#has_unsaved_changes(), 1)
    3   0.000322   0.000060         call gitgutter#hunk#set_hunks(gitgutter#diff#parse_diff(diff))
    3   0.000288   0.000027         let modified_lines = gitgutter#diff#process_hunks(gitgutter#hunk#hunks())
                            
    3              0.000012         if len(modified_lines) > g:gitgutter_max_signs
                                      call gitgutter#utility#warn('exceeded maximum number of signs (configured by g:gitgutter_max_signs).')
                                      call gitgutter#sign#clear_signs()
                                      return
                                    endif
                            
    3              0.000006         if g:gitgutter_signs || g:gitgutter_highlight_lines
    3   0.020669   0.000029           call gitgutter#sign#update_signs(modified_lines)
    3              0.000002         endif
                            
    3   0.000057   0.000024         call gitgutter#utility#save_last_seen_change()
    3              0.000002       endif
    3              0.000004     catch /diff failed/
                                  call gitgutter#hunk#reset()
                                endtry
    3              0.000002   else
    1   0.000008   0.000004     call gitgutter#hunk#reset()
    1              0.000001   endif

FUNCTION  vimproc#util#iconv()
Called 18 times
Total time:   0.000275
 Self time:   0.000216

count  total (s)   self (s)
   18   0.000131   0.000072   if !vimproc#util#has_iconv() || a:expr == '' || a:from == '' || a:to == '' || a:from ==# a:to
                                return a:expr
                              endif
                            
   18              0.000081   let result = iconv(a:expr, a:from, a:to)
   18              0.000029   return result != '' ? result : a:expr

FUNCTION  airline#parts#iminsert()
Called 70 times
Total time:   0.000393
 Self time:   0.000393

count  total (s)   self (s)
   70              0.000152   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
   70              0.000042   return ''

FUNCTION  <SNR>213__encode_name()
Called 6 times
Total time:   0.000396
 Self time:   0.000208

count  total (s)   self (s)
                              " Check cache directory.
    6              0.000031   if !isdirectory(a:cache_dir)
                                call mkdir(a:cache_dir, 'p')
                              endif
    6              0.000011   let cache_dir = a:cache_dir
    6              0.000068   if cache_dir !~ '/$'
    6              0.000027     let cache_dir .= '/'
    6              0.000004   endif
                            
    6   0.000225   0.000037   return cache_dir . s:_create_hash(cache_dir, a:filename)

FUNCTION  <SNR>182_set_complete_results_pos()
Called 7 times
Total time:   0.000625
 Self time:   0.000471

count  total (s)   self (s)
                              " Try omnifunc completion. "{{{
    7              0.000011   let complete_results = {}
   14              0.000024   for [omnifunc, pattern] in a:funcs
    7   0.000202   0.000100     if neocomplete#is_auto_complete() && (pattern == ''     || a:cur_text !~# '\%(' . pattern . '\m\)$')
    5              0.000006       continue
                                endif
                            
                                " Save pos.
    2              0.000004     let pos = getpos('.')
                            
    2              0.000002     try
    2   0.000067   0.000015       let complete_pos = call(omnifunc, [1, ''])
    2              0.000003     catch
                                  call neocomplete#print_error( 'Error occurred calling omnifunction: ' . omnifunc)
                                  call neocomplete#print_error(v:throwpoint)
                                  call neocomplete#print_error(v:exception)
                                  let complete_pos = -1
                                finally
    2              0.000005       if getpos('.') != pos
                                    call setpos('.', pos)
                                  endif
    2              0.000001     endtry
                            
    2              0.000002     if complete_pos < 0
                                  continue
                                endif
                            
    2              0.000006     let complete_str = a:cur_text[complete_pos :]
                            
    2              0.000011     let complete_results[omnifunc] = { 'candidates' : [], 'complete_pos' : complete_pos, 'complete_str' : complete_str, 'omnifunc' : omnifunc,}
    2              0.000002   endfor
                              "}}}
                            
    7              0.000007   return complete_results

FUNCTION  <SNR>183_uniq_by()
Called 13 times
Total time:   0.006332
 Self time:   0.006332

count  total (s)   self (s)
   13              0.000684   let list = map(copy(a:list), printf('[v:val, %s]', a:f))
   13              0.000018   let i = 0
   13              0.000016   let seen = {}
  503              0.000639   while i < len(list)
  490              0.001282     let key = string(list[i][1])
  490              0.000773     if has_key(seen, key)
  241              0.000469       call remove(list, i)
  241              0.000123     else
  249              0.000367       let seen[key] = 1
  249              0.000204       let i += 1
  249              0.000123     endif
  490              0.000239   endwhile
   13              0.000249   return map(list, 'v:val[0]')

FUNCTION  neocomplete#is_cache_disabled()
Called 65 times
Total time:   0.002993
 Self time:   0.001923

count  total (s)   self (s)
   65              0.000301   let ignore_filetypes = ['fuf', 'ku']
   65              0.000283   let bufnr = a:0 > 0 ? a:1 : bufnr('%')
   65   0.002322   0.001252   return !neocomplete#is_enabled() || index(ignore_filetypes, &filetype) >= 0 || neocomplete#get_current_neocomplete().lock || (g:neocomplete#lock_buffer_name_pattern != '' &&   bufname(bufnr) =~ g:neocomplete#lock_buffer_name_pattern)

FUNCTION  <SNR>114_new_builder()
Called 6 times
Total time:   0.000369
 Self time:   0.000226

count  total (s)   self (s)
    6              0.000074   let builder_context = { 'active'        : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
    6              0.000014   if get(g:, 'airline_powerline_fonts', 0)
    6              0.000028     let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
    6              0.000024     let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
    6              0.000004   else
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
                              endif
                            
    6   0.000174   0.000031   return airline#builder#new(builder_context)

FUNCTION  gitgutter#sign#remove_signs()
Called 3 times
Total time:   0.005368
 Self time:   0.005361

count  total (s)   self (s)
    3   0.000023   0.000016   let bufnr = gitgutter#utility#bufnr()
    3              0.000023   if a:all_signs && s:supports_star && empty(getbufvar(bufnr, 'gitgutter_other_signs'))
    3              0.000009     let dummy_sign_present = getbufvar(bufnr, 'gitgutter_dummy_sign')
    3              0.000017     execute "sign unplace * buffer=" . bufnr
    3              0.000002     if dummy_sign_present
    1              0.005226       execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
    1              0.000003     endif
    3              0.000002   else
                                for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
                              endif

FUNCTION  <SNR>68_repo_head_ref()
Called 1 time
Total time:   0.000065
 Self time:   0.000055

count  total (s)   self (s)
    1   0.000039   0.000033   if !filereadable(self.dir('HEAD'))
                                return ''
                              endif
    1   0.000023   0.000019   return readfile(self.dir('HEAD'))[0]

FUNCTION  neocomplete#get_context_filetype()
Called 41 times
Total time:   0.000886
 Self time:   0.000553

count  total (s)   self (s)
   41              0.000162   let neocomplete = exists('b:neocomplete') ? b:neocomplete : neocomplete#get_current_neocomplete()
                            
   41              0.000140   if a:0 != 0 || mode() !=# 'i' || neocomplete.context_filetype == ''
    9   0.000384   0.000051     call neocomplete#context_filetype#set()
    9              0.000006   endif
                            
   41              0.000048   return neocomplete.context_filetype

FUNCTION  neocomplete#util#uniq()
Called 6 times
Total time:   0.006173
 Self time:   0.000053

count  total (s)   self (s)
    6   0.006171   0.000051   return call(s:get_list().uniq, a:000)

FUNCTION  neocomplete#helper#get_force_omni_complete_pos()
Called 11 times
Total time:   0.000820
 Self time:   0.000529

count  total (s)   self (s)
                              " Check eskk complete length.
   11   0.000095   0.000047   if neocomplete#is_eskk_enabled() && exists('g:eskk#start_completion_length')
                                if !neocomplete#is_eskk_convertion(a:cur_text) || !neocomplete#is_multibyte_input(a:cur_text)
                                  return -1
                                endif
                            
                                let complete_pos = call(&l:omnifunc, [1, ''])
                                let complete_str = a:cur_text[complete_pos :]
                                return (neocomplete#util#mb_strlen(complete_str) >= g:eskk#start_completion_length) ? complete_pos : -1
                              endif
                            
   11   0.000217   0.000043   let filetype = neocomplete#get_context_filetype()
   11              0.000019   let omnifunc = &l:omnifunc
                            
   11   0.000116   0.000047   if neocomplete#helper#check_invalid_omnifunc(omnifunc)
                                return -1
                              endif
                            
   11              0.000014   let pattern = ''
                            
   11              0.000035   if has_key(g:neocomplete#force_omni_input_patterns, omnifunc)
                                let pattern = g:neocomplete#force_omni_input_patterns[omnifunc]
                              elseif filetype != '' && get(g:neocomplete#force_omni_input_patterns, filetype, '') != ''
                                let pattern = g:neocomplete#force_omni_input_patterns[filetype]
                              endif
                            
   11              0.000016   if pattern == ''
   11              0.000009     return -1
                              endif
                            
                              return match(a:cur_text, '\%(' . pattern . '\m\)$')

FUNCTION  neocomplete#helper#get_syn_name()
Called 10 times
Total time:   0.000346
 Self time:   0.000346

count  total (s)   self (s)
   10              0.000340   return len(getline('.')) < 200 ? synIDattr(synIDtrans(synID(line('.'), mode() ==# 'i' ?          col('.')-1 : col('.'), a:is_trans)), 'name') : ''

FUNCTION  neocomplete#context_filetype#set()
Called 21 times
Total time:   0.000732
 Self time:   0.000602

count  total (s)   self (s)
   21   0.000218   0.000088   let neocomplete = neocomplete#get_current_neocomplete()
   21              0.000076   let context_filetype = s:exists_context_filetype ? context_filetype#get_filetype() : &filetype
   21              0.000030   if context_filetype == ''
                                let context_filetype = 'nothing'
                              endif
   21              0.000059   let neocomplete.context_filetype = context_filetype
   21              0.000232   let neocomplete.context_filetypes = s:exists_context_filetype ?  context_filetype#get_filetypes(context_filetype) :  [context_filetype] + split(context_filetype, '\.')
                            
   21              0.000028   return neocomplete.context_filetype

FUNCTION  syntastic#log#debugShowOptions()
Called 1 time
Total time:   0.000007
 Self time:   0.000005

count  total (s)   self (s)
    1   0.000006   0.000004     if !s:_isDebugEnabled(a:level)
    1              0.000001         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)

FUNCTION  airline#statusline()
Called 107 times
Total time:   0.001291
 Self time:   0.001291

count  total (s)   self (s)
  107              0.000517   if has_key(s:contexts, a:winnr)
  107              0.000639     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  vimproc#system_bg()
Called 1 time
Total time:   0.007231
 Self time:   0.000153

count  total (s)   self (s)
                              " Open pipe.
    1              0.000004   if type(a:cmdline) == type('')
                                if a:cmdline =~ '&\s*$'
                                  let cmdline = substitute(a:cmdline, '&\s*$', '', '')
                                  return vimproc#system_bg(cmdline)
                                endif
                            
                                let args = vimproc#parser#parse_statements(a:cmdline)
                                for arg in args
                                  let arg.statement = vimproc#parser#parse_pipe(arg.statement)
                                endfor
                              else
    1              0.000047     let args = [{ 'statement' : [ { 'fd' : { 'stdin' : '', 'stdout' : '', 'stderr' : '' }, 'args' : a:cmdline  }], 'condition' : 'always', 'cwd' : getcwd(), }]
    1              0.000004   endif
                            
    1   0.006593   0.000024   let subproc = vimproc#pgroup_open(args)
    1              0.000002   if empty(subproc)
                                " Not supported path error.
                                return ''
                              endif
                            
                              " Close handles.
    1   0.000516   0.000007   call s:close_all(subproc)
                            
    1              0.000003   let s:bg_processes[subproc.pid] = subproc.pid
                            
    1              0.000002   return ''

FUNCTION  airline#check_mode()
Called 107 times
Total time:   0.944197
 Self time:   0.006262

count  total (s)   self (s)
  107              0.000301   let context = s:contexts[a:winnr]
                            
  107              0.000290   if get(w:, 'airline_active', 1)
   70              0.000146     let l:m = mode()
   70              0.000107     if l:m ==# "i"
   34              0.000058       let l:mode = ['insert']
   34              0.000030     elseif l:m ==# "R"
    1              0.000002       let l:mode = ['replace']
    1              0.000000     elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                else
   35              0.000066       let l:mode = ['normal']
   35              0.000016     endif
   70              0.000264     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   70              0.000044   else
   37              0.000075     let l:mode = ['inactive']
   37              0.000148     let w:airline_current_mode = get(g:airline_mode_map, '__')
   37              0.000066   endif
                            
  107              0.000250   if g:airline_detect_modified && &modified
   50              0.000135     call add(l:mode, 'modified')
   50              0.000026   endif
                            
  107              0.000149   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
  107              0.000129   if &readonly || ! &modifiable
   37              0.000094     call add(l:mode, 'readonly')
   37              0.000024   endif
                            
  107              0.000294   let mode_string = join(l:mode)
  107              0.000346   if get(w:, 'airline_lastmode', '') != mode_string
   12   0.001233   0.000063     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   12   0.936909   0.000144     call airline#highlighter#highlight(l:mode)
   12              0.000035     let w:airline_lastmode = mode_string
   12              0.000008   endif
                            
  107              0.000090   return ''

FUNCTION  neocomplete#util#is_complete_select()
Called 6 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    6              0.000024   return has('patch-7.4.775')

FUNCTION  <SNR>82_ClearCache()
Called 1 time
Total time:   0.001461
 Self time:   0.000343

count  total (s)   self (s)
    1   0.001068   0.000012     call s:notifiers.reset(g:SyntasticLoclist.current())
    1   0.000391   0.000329     call b:syntastic_loclist.destroy()

FUNCTION  neocomplete#helper#check_invalid_omnifunc()
Called 25 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
   25              0.000130   return a:omnifunc == '' || (a:omnifunc !~ '#' && !exists('*' . a:omnifunc))

FUNCTION  airline#util#append()
Called 210 times
Total time:   0.002026
 Self time:   0.002026

count  total (s)   self (s)
  210              0.000396   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  210              0.000673   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  210              0.000543   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>82_UpdateErrors()
Called 1 time
Total time:   0.228208
 Self time:   0.000173

count  total (s)   self (s)
    1   0.000018   0.000008     call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
    1   0.000019   0.000012     call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, s:_DEBUG_DUMP_OPTIONS)
    1   0.000013   0.000007     call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
    1   0.000016   0.000010     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
    1   0.000047   0.000008     call s:modemap.synch()
                            
    1   0.000121   0.000009     if s:_skip_file()
                                    return
                                endif
                            
    1   0.000094   0.000009     let run_checks = !a:auto_invoked || s:modemap.doAutoChecking()
    1              0.000002     if run_checks
    1   0.226660   0.000033         call s:CacheErrors(a:checker_names)
    1              0.000003         unlockvar! b:syntastic_changedtick
    1              0.000001         let b:syntastic_changedtick = b:changedtick
    1              0.000001         lockvar! b:syntastic_changedtick
    1              0.000001     else
                                    if a:auto_invoked
                                        return
                                    endif
                                endif
                            
    1   0.000013   0.000003     let loclist = g:SyntasticLoclist.current()
                            
    1              0.000002     if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
                                endif
                            
                                " populate loclist and jump {{{3
    1   0.000010   0.000004     let do_jump = syntastic#util#var('auto_jump') + 0
    1              0.000001     if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
                                elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
                                elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
                                endif
                            
    1              0.000003     let w:syntastic_loclist_set = 0
    1   0.000009   0.000003     if syntastic#util#var('always_populate_loc_list') || do_jump
    1   0.000009   0.000004         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist (new)')
    1   0.000008   0.000007         call setloclist(0, loclist.getRaw())
    1              0.000001         let w:syntastic_loclist_set = 1
    1   0.000005   0.000004         if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
                                    endif
    1              0.000001     endif
                                " }}}3
                            
    1   0.001120   0.000006     call s:notifiers.refresh(loclist)

FUNCTION  gitgutter#diff#is_modified_and_added()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  <SNR>68_repo_dir()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000009   return join([self.git_dir]+a:000,'/')

FUNCTION  <SNR>114_get_buffer_list()
Called 448 times
Total time:   2.773349
 Self time:   2.773349

count  total (s)   self (s)
  448              0.000747   let buffers = []
  448              0.000976   let cur = bufnr('%')
262976              0.209731   for nr in range(1, bufnr('$'))
262528              0.418222     if buflisted(nr) && bufexists(nr)
10304              0.011304       for ex in s:excludes
                                    if match(bufname(nr), ex)
                                      continue
                                    endif
                                  endfor
10304              0.023339       if getbufvar(nr, 'current_syntax') == 'qf'
                                    continue
                                  endif
10304              0.016437       call add(buffers, nr)
10304              0.005115     endif
262528              0.121792   endfor
                            
  448              0.002205   let s:current_buffer_list = buffers
  448              0.000523   return buffers

FUNCTION  <SNR>145_close_all()
Called 1 time
Total time:   0.000509
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000002   if has_key(a:self, 'stdin')
    1   0.000353   0.000006     call a:self.stdin.close()
    1              0.000001   endif
    1              0.000002   if has_key(a:self, 'stdout')
    1   0.000110   0.000003     call a:self.stdout.close()
    1              0.000000   endif
    1              0.000002   if has_key(a:self, 'stderr')
    1   0.000036   0.000002     call a:self.stderr.close()
    1              0.000001   endif

FUNCTION  <SNR>171_check_source()
Called 1 time
Total time:   0.015350
 Self time:   0.004890

count  total (s)   self (s)
                              " Check new buffer.
    1   0.015133   0.004673   call map(filter(range(1, bufnr('$')), " (v:val != bufnr('%') || neocomplete#has_vimproc()) && (!has_key(s:buffer_sources, v:val) && buflisted(v:val)   || (has_key(s:buffer_sources, v:val) &&     s:buffer_sources[v:val].cached_time         < getftime(s:buffer_sources[v:val].path))) && (!neocomplete#is_locked(v:val) ||    g:neocomplete#disable_auto_complete) && s:should_create_cache(v:val) "), 's:make_cache_file(v:val)')
                            
                              " Remove unlisted buffers.
    1              0.000209   call filter(s:buffer_sources, "v:key == bufnr('%') || buflisted(str2nr(v:key))")

FUNCTION  neocomplete#complete#_set_results_pos()
Called 10 times
Total time:   0.014337
 Self time:   0.004623

count  total (s)   self (s)
                              " Initialize sources.
   10   0.000092   0.000034   let neocomplete = neocomplete#get_current_neocomplete()
                            
   10   0.000178   0.000030   let filetype = neocomplete#get_context_filetype()
   10              0.000050   let sources = (a:0 > 0) ? a:1 : (filetype ==# neocomplete.sources_filetype) ? neocomplete.sources : neocomplete#helper#get_sources_list()
                            
   10              0.000034   let pos = winsaveview()
                            
                              " Try source completion. "{{{
   10              0.000013   let complete_sources = []
   70   0.002159   0.000326   for source in filter(values(sources), 'neocomplete#helper#is_enabled_source(v:val, filetype)')
   60              0.000070     if !source.loaded
                                  call neocomplete#helper#call_hook(source, 'on_init', {})
                                  let source.loaded = 1
                                endif
                            
   60              0.000098     let context = source.neocomplete__context
   60              0.000118     let context.input = a:cur_text
   60              0.000088     let context.filetype = filetype
   60   0.000907   0.000295     let context.filetypes = neocomplete#context_filetype#filetypes()
                            
   60              0.000049     try
   60   0.007605   0.000861       let complete_pos = s:use_previous_result(source, context) ? context.prev_complete_pos : has_key(source, 'get_complete_position') ? source.get_complete_position(context) : neocomplete#helper#match_word(context.input,    neocomplete#get_keyword_pattern_end(filetype, source.name))[0]
   60              0.000046     catch
                                  call neocomplete#print_error(v:throwpoint)
                                  call neocomplete#print_error(v:exception)
                                  call neocomplete#print_error( 'Error occurred in source''s get_complete_position()!')
                                  call neocomplete#print_error( 'Source name is ' . source.name)
                                  return complete_sources
                                finally
   60              0.000274       if winsaveview() != pos
                                    call winrestview(pos)
                                  endif
   60              0.000044     endtry
                            
   60              0.000062     if complete_pos < 0
   35              0.000053       let context.complete_pos = -1
   35              0.000051       let context.complete_str = ''
   35              0.000038       continue
                                endif
                            
   25              0.000065     let complete_str = context.input[complete_pos :]
   25   0.000439   0.000120     if neocomplete#is_auto_complete() && len(complete_str) < source.min_pattern_length
                                  " Skip.
    6              0.000006       let context.complete_pos = -1
    6              0.000010       let context.complete_str = ''
    6              0.000006       continue
                                endif
                            
   19              0.000026     let context.complete_pos = complete_pos
   19              0.000034     let context.complete_str = complete_str
   19              0.000048     call add(complete_sources, source)
   19              0.000013   endfor
                              "}}}
                            
   10              0.000009   return complete_sources

FUNCTION  neocomplete#get_cur_text()
Called 30 times
Total time:   0.002912
 Self time:   0.000339

count  total (s)   self (s)
                              " Return cached text.
   30   0.000298   0.000109   let neocomplete = neocomplete#get_current_neocomplete()
   30   0.002573   0.000189   return (a:0 == 0 && mode() ==# 'i' &&  neocomplete.cur_text != '') ? neocomplete.cur_text : neocomplete#helper#get_cur_text()

FUNCTION  airline#themes#get_highlight()
Called 3796 times
Total time:   0.415947
 Self time:   0.021759

count  total (s)   self (s)
 3796   0.414832   0.020644   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  neocomplete#helper#complete_check()
Called 34 times
Total time:   0.001583
 Self time:   0.000969

count  total (s)   self (s)
   34   0.000334   0.000113   let neocomplete = neocomplete#get_current_neocomplete()
   34              0.000033   if g:neocomplete#enable_debug
                                echomsg split(reltimestr(reltime(neocomplete.start_time)))[0]
                              endif
   34   0.000826   0.000433   let ret = neocomplete#is_auto_complete()     && g:neocomplete#skip_auto_completion_time != ''     && split(reltimestr(reltime(neocomplete.start_time)))[0] >          g:neocomplete#skip_auto_completion_time
   34              0.000031   if ret
                                let neocomplete = neocomplete#get_current_neocomplete()
                                let neocomplete.skipped = 1
                            
                                call neocomplete#print_debug('Skipped.')
                              endif
                            
   34              0.000027   return ret

FUNCTION  airline#parts#ffenc()
Called 70 times
Total time:   0.000767
 Self time:   0.000767

count  total (s)   self (s)
   70              0.000729   return printf('%s%s', &fenc, strlen(&ff) > 0 ? '['.&ff.']' : '')

FUNCTION  <SNR>145_vp_pipe_open()
Called 1 time
Total time:   0.003332
 Self time:   0.000194

count  total (s)   self (s)
    1              0.000001   try
    1   0.000004   0.000003     if vimproc#util#is_windows()
                                  let cmdline = s:quote_arg(substitute(a:argv[0], '/', '\', 'g'))
                                  for arg in a:argv[1:]
                                    let cmdline .= ' ' . s:quote_arg(arg)
                                  endfor
                                  let [pid; fdlist] = s:libcall('vp_pipe_open', [a:npipe, a:hstdin, a:hstdout, a:hstderr, cmdline])
                                else
    1   0.003284   0.000147       let [pid; fdlist] = s:libcall('vp_pipe_open', [a:npipe, a:hstdin, a:hstdout, a:hstderr, len(a:argv)] + a:argv)
    1              0.000001     endif
    1              0.000001   catch
                                call s:print_error(v:throwpoint)
                                call s:print_error(v:exception)
                                call s:print_error( 'Error occurred in calling s:vp_pipe_open()')
                                call s:print_error(printf( 'a:argv = %s', string(a:argv)))
                                call s:print_error(printf( 'original a:argv = %s', vimproc#util#iconv(   string(a:argv), vimproc#util#systemencoding(), &encoding)))
                              endtry
                            
    1              0.000002   if a:npipe != len(fdlist)
                                call s:print_error(printf( 'a:npipe = %d, a:argv = %s', a:npipe, string(a:argv)))
                                call s:print_error(printf( 'pid = %d, fdlist = %s', pid, string(fdlist)))
                                echoerr 'Bug behavior is detected!: ' . pid
                              endif
                            
    1              0.000006   return [pid] + fdlist

FUNCTION  neocomplete#get_keyword_pattern()
Called 40 times
Total time:   0.001318
 Self time:   0.001042

count  total (s)   self (s)
   40              0.000136   let filetype = a:0 != 0? a:1 : neocomplete#get_context_filetype()
   40              0.000042   if a:0 < 2
                                return neocomplete#helper#unite_patterns( g:neocomplete#keyword_patterns, filetype)
                              endif
                            
   40   0.000452   0.000176   let source = neocomplete#variables#get_source(a:2)
   40              0.000106   if !has_key(source, 'neocomplete__keyword_patterns')
                                let source.neocomplete__keyword_patterns = {}
                              endif
   40              0.000095   if !has_key(source.neocomplete__keyword_patterns, filetype)
                                let source.neocomplete__keyword_patterns[filetype] = neocomplete#helper#unite_patterns(         source.keyword_patterns, filetype)
                              endif
                            
   40              0.000070   return source.neocomplete__keyword_patterns[filetype]

FUNCTION  vimproc#util#substitute_path_separator()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTION  neocomplete#get_keyword_pattern_end()
Called 40 times
Total time:   0.001609
 Self time:   0.000291

count  total (s)   self (s)
   40   0.001584   0.000266   return '\%('.call('neocomplete#get_keyword_pattern', a:000).'\m\)$'

FUNCTION  gitgutter#sign#update_signs()
Called 3 times
Total time:   0.020640
 Self time:   0.000296

count  total (s)   self (s)
    3   0.000529   0.000030   call gitgutter#sign#find_current_signs()
                            
    3              0.000044   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
    3   0.000196   0.000047   let obsolete_signs = gitgutter#sign#obsolete_gitgutter_signs_to_remove(new_gitgutter_signs_line_numbers)
                            
    3              0.000014   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
    3              0.000004   if flicker_possible
    1   0.013577   0.000023     call gitgutter#sign#add_dummy_sign()
    1              0.000001   endif
                            
    3   0.005401   0.000033   call gitgutter#sign#remove_signs(obsolete_signs, s:remove_all_old_signs)
    3   0.000788   0.000033   call gitgutter#sign#upsert_new_gitgutter_signs(a:modified_lines)
                            
    3              0.000004   if flicker_possible
    1   0.000026   0.000007     call gitgutter#sign#remove_dummy_sign(0)
    1              0.000000   endif

FUNCTION  syntastic#util#shescape()
Called 2 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    2              0.000027     return a:string =~# '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)

FUNCTION  <SNR>182_get_omni_funcs()
Called 7 times
Total time:   0.001570
 Self time:   0.001078

count  total (s)   self (s)
    7              0.000010   let funcs = []
   21              0.000062   for ft in insert(split(a:filetype, '\.'), '_')
   14   0.000164   0.000104     let omnifuncs = neocomplete#util#convert2list( get(g:neocomplete#sources#omni#functions, ft, &l:omnifunc))
                            
   28              0.000039     for omnifunc in omnifuncs
   14   0.000128   0.000051       if neocomplete#helper#check_invalid_omnifunc(omnifunc)
                                    " omnifunc is irregal.
                                    continue
                                  endif
                            
   14              0.000079       if get(g:neocomplete#sources#omni#input_patterns, omnifunc, '') != ''
                                    let pattern = g:neocomplete#sources#omni#input_patterns[omnifunc]
                                  elseif get(g:neocomplete#sources#omni#input_patterns, ft, '') != ''
    7              0.000018         let pattern = g:neocomplete#sources#omni#input_patterns[ft]
    7              0.000004       else
    7              0.000010         let pattern = ''
    7              0.000003       endif
                            
   14              0.000018       if pattern == ''
    7              0.000007         continue
                                  endif
                            
    7              0.000027       call add(funcs, [omnifunc, pattern])
    7              0.000003     endfor
   14              0.000011   endfor
                            
    7   0.000393   0.000038   return s:List.uniq(funcs)

FUNCTION  NERDTreeGetGitStatusPrefix()
Called 72 times
Total time:   0.075119
 Self time:   0.004197

count  total (s)   self (s)
   72              0.000285     if localtime() - s:GitStatusCacheTime > s:GitStatusCacheTimeExpiry
    2              0.000007         let s:GitStatusCacheTime = localtime()
    2   0.057276   0.000039         call g:NERDTreeGitStatusRefresh()
    2              0.000005     endif
   72   0.006386   0.000293     let l:pathStr = a:path.str()
   72   0.006589   0.000463     let l:cwd = b:NERDTreeRoot.path.str() . a:path.Slash()
   72   0.000594   0.000155     if nerdtree#runningWindows()
                                    let l:pathStr = a:path.WinToUnixPath(l:pathStr)
                                    let l:cwd = a:path.WinToUnixPath(l:cwd)
                                endif
   72              0.001068     let l:pathStr = substitute(l:pathStr, fnameescape(l:cwd), '', '')
   72              0.000103     let l:statusKey = ''
   72              0.000078     if a:path.isDirectory
   25              0.000169         let l:statusKey = get(b:NERDTreeCachedGitDirtyDir, fnameescape(l:pathStr . '/'), '')
   25              0.000017     else
   47              0.000341         let l:statusKey = get(b:NERDTreeCachedGitFileStatus, fnameescape(l:pathStr), '')
   47              0.000031     endif
   72   0.001313   0.000286     return s:NERDTreeGetIndicator(l:statusKey)

FUNCTION  neocomplete#util#substitute_path_separator()
Called 6 times
Total time:   0.000234
 Self time:   0.000157

count  total (s)   self (s)
    6   0.000230   0.000153   return call(s:get_prelude().substitute_path_separator, a:000)

FUNCTION  <SNR>182_get_complete_pos()
Called 7 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    7              0.000016   if empty(a:complete_results)
    5              0.000005     return -1
                              endif
                            
    2              0.000004   let complete_pos = col('.')
    4              0.000020   for result in values(a:complete_results)
    2              0.000003     if complete_pos > result.complete_pos
    2              0.000003       let complete_pos = result.complete_pos
    2              0.000001     endif
    2              0.000001   endfor
                            
    2              0.000001   return complete_pos

FUNCTION  <SNR>171_make_cache_file()
Called 1 time
Total time:   0.010339
 Self time:   0.000145

count  total (s)   self (s)
                              " Initialize source.
    1              0.000005   if !has_key(s:buffer_sources, a:srcname)
                                call s:initialize_source(a:srcname)
                              endif
                            
    1              0.000004   let source = s:buffer_sources[a:srcname]
                            
    1              0.000037   if !filereadable(source.path) || getbufvar(a:srcname, '&modified') || getbufvar(a:srcname, '&buftype') =~ 'nofile\|acwrite'
                                call s:make_cache_buffer(a:srcname)
                                return
                              endif
                            
    1   0.000019   0.000009   call neocomplete#print_debug('make_cache_buffer: ' . source.path)
                            
    1   0.010235   0.000051   let source.cache_name = neocomplete#cache#async_load_from_file(     'buffer_cache', source.path,     source.keyword_pattern, 'B')
    1              0.000004   let source.cached_time = localtime()
    1              0.000008   let source.filetype = getbufvar(a:srcname, '&filetype')
    1              0.000009   let s:async_dictionary_list[source.path] = [{ 'filename' : source.path, 'cachename' : source.cache_name, }]

FUNCTION  neocomplete#helper#match_word()
Called 40 times
Total time:   0.000959
 Self time:   0.000959

count  total (s)   self (s)
   40              0.000119   let pattern = a:0 >= 1 ? a:1 : neocomplete#get_keyword_pattern_end()
                            
                              " Check wildcard.
   40              0.000544   let complete_pos = match(a:cur_text, pattern)
                            
   40              0.000125   let complete_str = (complete_pos >=0) ? a:cur_text[complete_pos :] : ''
                            
   40              0.000072   return [complete_pos, complete_str]

FUNCTION  gitgutter#sign#find_current_signs()
Called 3 times
Total time:   0.000499
 Self time:   0.000484

count  total (s)   self (s)
    3   0.000035   0.000020   let bufnr = gitgutter#utility#bufnr()
    3              0.000015   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
    3              0.000006   let other_signs = []      " [<line_number (number),...]
    3              0.000006   let dummy_sign_placed = 0
                            
    3              0.000009   redir => signs
    3              0.000032     silent execute "sign place buffer=" . bufnr
    3              0.000012   redir END
                            
    3              0.000043   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
                                let components  = split(sign_line)
                                let name        = split(components[2], '=')[1]
                                if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
                                  let line_number = str2nr(split(components[0], '=')[1])
                                  if name =~# 'GitGutter'
                                    let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
                                    if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
                                    let gitgutter_signs[line_number] = {'id': id, 'name': name}
                                  else
                                    call add(other_signs, line_number)
                                  endif
                                end
                              endfor
                            
    3              0.000038   call setbufvar(bufnr, 'gitgutter_dummy_sign', dummy_sign_placed)
    3              0.000139   call setbufvar(bufnr, 'gitgutter_gitgutter_signs', gitgutter_signs)
    3              0.000014   call setbufvar(bufnr, 'gitgutter_other_signs', other_signs)

FUNCTION  syntastic#util#unique()
Called 2 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    2              0.000005     let seen = {}
    2              0.000003     let uniques = []
    4              0.000005     for e in a:list
    2              0.000004         if !has_key(seen, e)
    2              0.000004             let seen[e] = 1
    2              0.000005             call add(uniques, e)
    2              0.000001         endif
    2              0.000002     endfor
    2              0.000002     return uniques

FUNCTION  neocomplete#sources#member#remake_cache()
Called 2 times
Total time:   0.000026
 Self time:   0.000017

count  total (s)   self (s)
    2   0.000015   0.000006   if !neocomplete#is_enabled()
                                call neocomplete#initialize()
                              endif
                            
    2              0.000006   if get(g:neocomplete#sources#member#prefix_patterns, a:filetype, '') == ''
    2              0.000001     return
                              endif
                            
                              for dictionary in filter(map(neocomplete#sources#dictionary#get_dictionaries(a:filetype),  "neocomplete#util#substitute_path_separator(      fnamemodify(v:val, ':p'))"), "filereadable(v:val) && (!has_key(s:member_sources, v:val)    || getftime(v:val) > s:member_sources[v:val].time)")
                                call s:make_cache_lines(dictionary, a:filetype, readfile(dictionary))
                              endfor

FUNCTION  <SNR>145_decode_size()
Called 3 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    3              0.000062   return (char2nr(a:str[a:off + 0]) - 0x80) * 0x10000000 + (char2nr(a:str[a:off + 1]) - 0x80) * 0x200000 + (char2nr(a:str[a:off + 2]) - 0x80) * 0x4000 + (char2nr(a:str[a:off + 3]) - 0x80) * 0x80 + (char2nr(a:str[a:off + 4]) - 0x80)

FUNCTION  unite#variables#current_unite()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000004   if !exists('s:current_unite')
                                let s:current_unite = {}
                              endif
                            
    1              0.000002   return s:current_unite

FUNCTION  airline#parts#filetype()
Called 70 times
Total time:   0.000158
 Self time:   0.000158

count  total (s)   self (s)
   70              0.000116   return &filetype

FUNCTION  gitgutter#diff#process_hunk()
Called 1 time
Total time:   0.000130
 Self time:   0.000084

count  total (s)   self (s)
    1              0.000002   let modifications = []
    1              0.000002   let from_line  = a:hunk[0]
    1              0.000002   let from_count = a:hunk[1]
    1              0.000001   let to_line    = a:hunk[2]
    1              0.000002   let to_count   = a:hunk[3]
                            
    1   0.000011   0.000009   if gitgutter#diff#is_added(from_count, to_count)
                                call gitgutter#diff#process_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(to_count)
                            
                              elseif gitgutter#diff#is_removed(from_count, to_count)
                                call gitgutter#diff#process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(from_count)
                            
                              elseif gitgutter#diff#is_modified(from_count, to_count)
                                call gitgutter#diff#process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(to_count)
                            
                              elseif gitgutter#diff#is_modified_and_added(from_count, to_count)
    1   0.000043   0.000010     call gitgutter#diff#process_modified_and_added(modifications, from_count, to_count, to_line)
    1   0.000010   0.000008     call gitgutter#hunk#increment_lines_added(to_count - from_count)
    1   0.000011   0.000009     call gitgutter#hunk#increment_lines_modified(from_count)
                            
    1              0.000002   elseif gitgutter#diff#is_modified_and_removed(from_count, to_count)
                                call gitgutter#diff#process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(to_count)
                                call gitgutter#hunk#increment_lines_removed(from_count - to_count)
                            
                              endif
    1              0.000001   return modifications

FUNCTION  neocomplete#cache#async_load_from_file()
Called 1 time
Total time:   0.010184
 Self time:   0.000186

count  total (s)   self (s)
    1   0.000958   0.000027   if !neocomplete#cache#check_old_cache(a:cache_dir, a:filename) || neocomplete#util#is_sudo()
                                return neocomplete#cache#encode_name(a:cache_dir, a:filename)
                              endif
                            
    1   0.000157   0.000006   let pattern_file_name = neocomplete#cache#encode_name('keyword_patterns', a:filename)
    1   0.000121   0.000004   let cache_name = neocomplete#cache#encode_name(a:cache_dir, a:filename)
                            
                              " Create pattern file.
    1   0.001021   0.000012   call neocomplete#cache#writefile( 'keyword_patterns', a:filename, [a:pattern])
                            
                              " args: funcname, outputname, filename pattern mark
                              "       minlen maxlen encoding
    1              0.000008   let fileencoding = &fileencoding == '' ? &encoding : &fileencoding
    1              0.000021   let argv = [  'load_from_file', cache_name, a:filename, pattern_file_name, a:mark,  g:neocomplete#min_keyword_length, fileencoding ]
    1   0.007867   0.000077   return s:async_load(argv, a:cache_dir, a:filename)

FUNCTION  <SNR>145_libcall()
Called 3 times
Total time:   0.003462
 Self time:   0.002920

count  total (s)   self (s)
    3   0.003053   0.002745   let stack_buf = libcall(g:vimproc#dll_path, a:func, s:encode_list(a:args))
    3              0.000022   if empty(stack_buf)
    2              0.000002     return []
                              endif
    1   0.000352   0.000118   let [result, err] = s:decode_list(stack_buf)
    1              0.000001   if err
                                let s:lasterr = result
                                let msg = vimproc#util#iconv(string(result), vimproc#util#systemencoding(), &encoding)
                            
                                throw printf('vimproc: %s: %s', a:func, msg)
                              endif
    1              0.000004   return result

FUNCTION  neocomplete#cache#get_cache_list()
Called 1 time
Total time:   0.000483
 Self time:   0.000093

count  total (s)   self (s)
    1              0.000002   let cache_list = a:async_cache_list
                            
    1              0.000002   let loaded_keywords = []
    1              0.000001   let loaded = 0
    2              0.000042   for cache in filter(copy(cache_list), 'filereadable(v:val.cachename)')
    1              0.000002     let loaded = 1
    1   0.000404   0.000014     let loaded_keywords = neocomplete#cache#load_from_cache( a:cache_dir, cache.filename, 1)
    1              0.000001   endfor
                            
    1              0.000018   call filter(cache_list, '!filereadable(v:val.cachename)')
                            
    1              0.000003   return [loaded, loaded_keywords]

FUNCTION  <SNR>176_process_delimiter()
Called 6 times
Total time:   0.000442
 Self time:   0.000442

count  total (s)   self (s)
    6              0.000010   let candidate = a:candidate
                            
    6              0.000037   let split_list = split(candidate.word, a:delimiter.'\ze.', 1)
    6              0.000034   let delimiter_sub = substitute( a:delimiter, '\\\(.\)', '\1', 'g')
    6              0.000054   let candidate.abbr = join( split(get(candidate, 'abbr', candidate.word),             a:delimiter.'\ze.', 1)[ : a:delim_cnt], delimiter_sub)
    6              0.000019   let candidate.word = join(split_list[ : a:delim_cnt], delimiter_sub)
                            
    6              0.000017   if g:neocomplete#max_keyword_width >= 0 && len(candidate.abbr) > g:neocomplete#max_keyword_width
                                let candidate.abbr = substitute(candidate.abbr, '\(\h\)\w*'.a:delimiter, '\1'.delimiter_sub, 'g')
                              endif
    6              0.000011   if a:delim_cnt+1 < len(split_list)
    6              0.000012     let candidate.abbr .= delimiter_sub . '~'
    6              0.000007     let candidate.dup = 0
                            
    6              0.000006     if g:neocomplete#enable_auto_delimiter
                                  let candidate.word .= delimiter_sub
                                endif
    6              0.000000   endif
                            
                              " Clear previous result.
    6              0.000167   let a:context.prev_candidates = []
    6              0.000008   let a:context.prev_complete_pos = -1
    6              0.000009   let a:context.prev_line = ''

FUNCTION  SyntasticRefreshCursor()
Called 12 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
   12              0.000050     if !exists('b:syntastic_private_messages') || empty(b:syntastic_private_messages)
                                    " file not checked
   12              0.000012         return
                                endif
                            
                                if !exists('b:syntastic_private_line')
                                    let b:syntastic_private_line = -1
                                endif
                                let l = line('.')
                                let current_messages = get(b:syntastic_private_messages, l, {})
                            
                                if !exists('b:syntastic_cursor_columns')
                                    let b:syntastic_cursor_columns = g:syntastic_cursor_columns
                                endif
                            
                                if b:syntastic_cursor_columns
                                    let c = virtcol('.')
                                    if !exists('b:syntastic_private_idx')
                                        let b:syntastic_private_idx = -1
                                    endif
                            
                                    if s:_is_same_index(l, b:syntastic_private_line, c, b:syntastic_private_idx, current_messages)
                                        return
                                    else
                                        let b:syntastic_private_line = l
                                    endif
                            
                                    if !empty(current_messages)
                                        let b:syntastic_private_idx = s:_find_index(c, current_messages)
                                        call syntastic#util#wideMsg(current_messages[b:syntastic_private_idx].text)
                                    else
                                        let b:syntastic_private_idx = -1
                                        echo
                                    endif
                                else
                                    if l == b:syntastic_private_line
                                        return
                                    endif
                                    let b:syntastic_private_line = l
                            
                                    if !empty(current_messages)
                                        call syntastic#util#wideMsg(current_messages[0].text)
                                    else
                                        echo
                                    endif
                                endif

FUNCTION  <SNR>82__resolve_filetypes()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000004     let type = len(a:filetypes) ? a:filetypes[0] : &filetype
    1              0.000010     return split( get(g:syntastic_filetype_map, type, type), '\m\.' )

FUNCTION  neocomplete#filters#fuzzy_escape()
Called 13 times
Total time:   0.000314
 Self time:   0.000197

count  total (s)   self (s)
                              " Escape string for lua regexp.
   13   0.000234   0.000117   let string = substitute(neocomplete#filters#escape(a:string), '\w', '\0.*', 'g')
   13              0.000023   if g:neocomplete#enable_camel_case && string =~ '\u'
                                let string = substitute(string, '\l', '[\0\u\0\E]', 'g')
                              endif
   13              0.000010   return string

FUNCTION  neocomplete#cache#load_from_cache()
Called 1 time
Total time:   0.000390
 Self time:   0.000184

count  total (s)   self (s)
    1              0.000003   let is_string = get(a:000, 0, 0)
                            
    1              0.000001   try
                                " Note: For neocomplete.
    1              0.000002     let list = []
                            
    1              0.000002     if is_string
    1              0.000001       lua << EOF
                            do
                              local ret = vim.eval('list')
                              local list = {}
                              for line in io.lines(vim.eval(
                                  'neocomplete#cache#encode_name(a:cache_dir, a:filename)')) do
                                list = (loadstring) and loadstring('return ' .. line)()
                                                    or  load('return ' .. line)()
                              end
                            
                              for i = 1, #list do
                                ret:add(list[i])
                              end
                            end
                            EOF
    1              0.000001     else
                                  let list = eval(get(neocomplete#cache#readfile( a:cache_dir, a:filename), 0, '[]'))
                                endif
                            
    1              0.000006     if !empty(list) && is_string && type(list[0]) != type('')
                                  " Type check.
                                  throw 'Type error'
                                endif
                            
    1              0.000002     return list
                              catch
                                " echomsg string(v:errmsg)
                                " echomsg string(v:exception)
                            
                                " Delete old cache file.
                                let cache_name = neocomplete#cache#encode_name(a:cache_dir, a:filename)
                                if filereadable(cache_name)
                                  call delete(cache_name)
                                endif
                            
                                return []
                              endtry

FUNCTION  neocomplete#util#escape_pattern()
Called 9 times
Total time:   0.000159
 Self time:   0.000066

count  total (s)   self (s)
    9   0.000157   0.000064   return call(s:get_prelude().escape_pattern, a:000)

FUNCTION  301()
Called 1 time
Total time:   0.000605
 Self time:   0.000043

count  total (s)   self (s)
    1   0.000011   0.000003     if self.enabled()
    1   0.000009   0.000004         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
    1   0.000550   0.000003         call self._reset()
    1              0.000002         let buf = bufnr('')
    1   0.000008   0.000006         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
    1              0.000001         for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
                                    endfor
    1              0.000001     endif

FUNCTION  302()
Called 1 time
Total time:   0.000726
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000002     if s:has_highlighting
    1   0.000012   0.000005         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
    1   0.000711   0.000006         call self._reset()
    1              0.000001     endif

FUNCTION  304()
Called 2 times
Total time:   0.001252
 Self time:   0.001252

count  total (s)   self (s)
  122              0.000697     for match in getmatches()
  120              0.000273         if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
  120              0.000043     endfor

FUNCTION  305()
Called 2 times
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
    2              0.000051     let newObj = copy(self)
                            
    2              0.000011     let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
                            
    2              0.000004     for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
    2              0.000003     let newObj._rawLoclist = llist
    2              0.000004     let newObj._name = ''
    2              0.000004     let newObj._owner = bufnr('')
    2              0.000002     let newObj._sorted = 0
    2              0.000005     let newObj._columns = g:syntastic_cursor_columns
                            
    2              0.000002     return newObj

FUNCTION  306()
Called 72 times
Total time:   0.000615
 Self time:   0.000615

count  total (s)   self (s)
   72              0.000292     if !exists('b:syntastic_loclist') || empty(b:syntastic_loclist)
                                    let b:syntastic_loclist = g:SyntasticLoclist.New([])
                                endif
   72              0.000078     return b:syntastic_loclist

FUNCTION  309()
Called 7 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    7              0.000009     return empty(self._rawLoclist)

FUNCTION  vimproc#util#is_windows()
Called 7 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    7              0.000008   return s:is_windows

FUNCTION  <SNR>82__ignore_file()
Called 2 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    2              0.000047     let fname = fnamemodify(a:filename, ':p')
    2              0.000006     for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
                                endfor
    2              0.000001     return 0

FUNCTION  <SNR>56_NERDTreeGetFileGitStatusKey()
Called 19 times
Total time:   0.000151
 Self time:   0.000151

count  total (s)   self (s)
   19              0.000051     if a:us ==# '?' && a:them ==# '?'
    6              0.000006         return 'Untracked'
                                elseif a:us ==# ' ' && a:them ==# 'M'
   13              0.000019         return 'Modified'
                                elseif a:us =~# '[MAC]'
                                    return 'Staged'
                                elseif a:us ==# 'R'
                                    return 'Renamed'
                                elseif a:us ==# 'U' || a:them ==# 'U' || a:us ==# 'A' && a:them ==# 'A' || a:us ==# 'D' && a:them ==# 'D'
                                    return 'Unmerged'
                                elseif a:them ==# 'D'
                                    return 'Deleted'
                                else
                                    return 'Unknown'
                                endif

FUNCTION  10()
Called 72 times
Total time:   0.003722
 Self time:   0.002552

count  total (s)   self (s)
   72   0.001187   0.000457     let self.cachedDisplayString = self.getLastPathComponent(1)
                            
   72              0.000076     if self.isExecutable
                                    let self.cachedDisplayString = self.cachedDisplayString . '*'
                                endif
                            
   72              0.000343     let self._bookmarkNames = []
   72   0.000748   0.000308     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
                                endfor
   72              0.000133     if !empty(self._bookmarkNames)
                                    let self.cachedDisplayString .= ' {' . join(self._bookmarkNames) . '}'
                                endif
                            
   72              0.000075     if self.isSymLink
                                    let self.cachedDisplayString .=  ' -> ' . self.symLinkDest
                                endif
                            
   72              0.000063     if self.isReadOnly
                                    let self.cachedDisplayString .=  ' [RO]'
                                endif

FUNCTION  19()
Called 106 times
Total time:   0.000570
 Self time:   0.000570

count  total (s)   self (s)
  106              0.000185     if self.cachedDisplayString ==# ""
                                    call self.cacheDisplayString()
                                endif
                            
  106              0.000094     return self.cachedDisplayString

FUNCTION  syntastic#util#stamp()
Called 3 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    3              0.000037     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  <SNR>109_get_hunks_gitgutter()
Called 70 times
Total time:   0.002326
 Self time:   0.000726

count  total (s)   self (s)
   70   0.001612   0.000379   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
                              endif
   70   0.000553   0.000186   return GitGutterGetHunkSummary()

FUNCTION  <SNR>145_decode_list()
Called 1 time
Total time:   0.000234
 Self time:   0.000167

count  total (s)   self (s)
    1              0.000002   let err = 0
                              " End Of Value
    1              0.000005   let EOV = "\xFF"
    1              0.000017   if a:str[0] != EOV
                                let err = 1
                                return [[a:str], err]
                              endif
    1              0.000015   let arr = []
    1              0.000006   let slen = strlen(a:str)
    1              0.000000   let off = 1
    4              0.000017   while slen - off >= 5
    3   0.000108   0.000041     let size = s:decode_size(a:str, off)
    3              0.000021     let arr += [a:str[off + 5 : off + 5 + size - 1]]
    3              0.000008     let off += 5 + size + 1
    3              0.000002   endwhile
    1              0.000002   return [arr, err]

FUNCTION  neocomplete#handler#_on_insert_enter()
Called 2 times
Total time:   0.000120
 Self time:   0.000074

count  total (s)   self (s)
    2   0.000041   0.000017   if !neocomplete#is_enabled()
                                return
                              endif
                            
    2   0.000034   0.000012   let neocomplete = neocomplete#get_current_neocomplete()
    2              0.000007   if neocomplete.linenr != line('.')
                                call neocomplete#helper#clear_result()
                              endif
    2              0.000006   let neocomplete.linenr = line('.')
                            
    2              0.000009   if &l:foldmethod ==# 'expr' && foldlevel('.') != 0
                                foldopen
                              endif

FUNCTION  <SNR>56_NERDTreeGetIndicator()
Called 72 times
Total time:   0.001027
 Self time:   0.001027

count  total (s)   self (s)
   72              0.000176     if exists('g:NERDTreeIndicatorMapCustom')
                                    let l:indicator = get(g:NERDTreeIndicatorMapCustom, a:statusKey, '')
                                    if l:indicator !=# ''
                                        return l:indicator
                                    endif
                                endif
   72              0.000232     let l:indicator = get(s:NERDTreeIndicatorMap, a:statusKey, '')
   72              0.000095     if l:indicator !=# ''
   20              0.000023         return l:indicator
                                endif
   52              0.000031     return ''

FUNCTION  gitgutter#utility#shellescape()
Called 6 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
    6              0.000064   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
    6              0.000007     return a:arg
                              elseif &shell =~# 'cmd' || gitgutter#utility#using_xolox_shell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
                                return shellescape(a:arg)
                              endif

FUNCTION  <SNR>181_get_member_pattern()
Called 16 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
   16              0.000083   return get(g:neocomplete#sources#member#input_patterns, a:filetype, get(g:neocomplete#sources#member#input_patterns, '_', ''))

FUNCTION  310()
Called 2 times
Total time:   0.000050
 Self time:   0.000018

count  total (s)   self (s)
    2              0.000003     if !exists('self._stamp')
                                    let self._stamp = []
                                    return 0
                                endif
    2   0.000041   0.000009     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  311()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002     return copy(self._rawLoclist)

FUNCTION  312()
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
    1              0.000001     return self._rawLoclist

FUNCTION  313()
Called 2 times
Total time:   0.000080
 Self time:   0.000033

count  total (s)   self (s)
    2   0.000077   0.000030     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])

FUNCTION  315()
Called 70 times
Total time:   0.003731
 Self time:   0.003731

count  total (s)   self (s)
   70              0.000181     if !exists('self._stl_format')
    1              0.000002         let self._stl_format = ''
    1              0.000001     endif
   70              0.000141     if !exists('self._stl_flag')
    1              0.000001         let self._stl_flag = ''
    1              0.000001     endif
                            
   70              0.000153     if g:syntastic_stl_format !=# self._stl_format
    1              0.000002         let self._stl_format = g:syntastic_stl_format
                            
    1              0.000001         if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        let flags = { '%':  '%', 't':  num_issues, 'e':  num_errors, 'w':  num_warnings, 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''), 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''), 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''), 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''), 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''), 'fe': (num_errors ? errors[0]['lnum'] : ''), 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''), 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''), 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
                                        let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
                                        let self._stl_flag = output
                                    else
    1              0.000001             let self._stl_flag = ''
    1              0.000001         endif
    1              0.000000     endif
                            
   70              0.000074     return self._stl_flag

FUNCTION  gitgutter#utility#system()
Called 3 times
Total time:   0.100591
 Self time:   0.001006

count  total (s)   self (s)
    3   0.000052   0.000013   if gitgutter#utility#using_xolox_shell()
                                let options = {'command': a:cmd, 'check': 0}
                                if a:0 > 0
                                  let options['stdin'] = a:1
                                endif
                                let ret = xolox#misc#os#exec(options)
                                let output = join(ret.stdout, "\n")
                                let s:exit_code = ret.exit_code
                              else
    3   0.100465   0.000919     silent let output = (a:0 == 0) ? system(a:cmd) : system(a:cmd, a:1)
    3              0.000018   endif
    3              0.000015   return output

FUNCTION  neocomplete#sources#member#make_cache_current_line()
Called 6 times
Total time:   0.002903
 Self time:   0.000076

count  total (s)   self (s)
    6   0.000045   0.000017   if !neocomplete#is_enabled()
                                call neocomplete#initialize()
                              endif
                            
                              " Make cache from current line.
    6   0.002838   0.000039   return s:make_cache_current_buffer(line('.')-1, line('.')+1)

FUNCTION  neocomplete#context_filetype#filetypes()
Called 124 times
Total time:   0.001229
 Self time:   0.000513

count  total (s)   self (s)
  124   0.001193   0.000477   return copy(neocomplete#get_current_neocomplete().context_filetypes)

FUNCTION  21()
Called 1 time
Total time:   0.000025
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000011   0.000004     if nerdtree#runningWindows()
                                    if a:fullpath =~ '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', "g")
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
                                else
    1              0.000003         let self.drive = ''
    1              0.000001     endif
                            

FUNCTION  26()
Called 887 times
Total time:   0.008132
 Self time:   0.008132

count  total (s)   self (s)
  887              0.001449     if empty(self.pathSegments)
                                    return ''
                                endif
  887              0.001699     let toReturn = self.pathSegments[-1]
  887              0.001037     if a:dirSlash && self.isDirectory
   25              0.000054         let toReturn = toReturn . '/'
   25              0.000012     endif
  887              0.000802     return toReturn

FUNCTION  29()
Called 350 times
Total time:   0.004920
 Self time:   0.001851

count  total (s)   self (s)
  350   0.004800   0.001731     return self.getLastPathComponent(0) =~# '^\.'

FUNCTION  <SNR>105_sync_active_winnr()
Called 13 times
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
   13              0.000081   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  <SNR>82_CacheErrors()
Called 1 time
Total time:   0.226627
 Self time:   0.000298

count  total (s)   self (s)
    1   0.000017   0.000009     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
    1   0.001469   0.000008     call s:ClearCache()
    1   0.000050   0.000009     let newLoclist = g:SyntasticLoclist.New([])
                            
    1   0.000112   0.000004     if !s:_skip_file()
                                    " debug logging {{{3
    1   0.000019   0.000008         call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
    1   0.000022   0.000015         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
    1   0.000025   0.000017         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
    1   0.000025   0.000010         let filetypes = s:_resolve_filetypes([])
    1   0.000019   0.000009         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(filetypes) > 1
    1              0.000003         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
    1              0.000003         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
    1              0.000001         let clist = []
    2              0.000004         for type in filetypes
    1   0.000122   0.000011             call extend(clist, s:registry.getCheckers(type, a:checker_names))
    1              0.000001         endfor
                            
    1              0.000002         let names = []
    1              0.000002         let unavailable_checkers = 0
    3              0.000007         for checker in clist
    2   0.000033   0.000022             let cname = checker.getFiletype() . '/' . checker.getName()
    2   0.000101   0.000011             if !checker.isAvailable()
    1   0.000010   0.000004                 call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
    1              0.000002                 let unavailable_checkers += 1
    1              0.000002                 continue
                                        endif
                            
    1   0.000013   0.000005             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
    1   0.224354   0.000015             let loclist = checker.getLocList()
                            
    1   0.000006   0.000004             if !loclist.isEmpty()
                                            if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
                                            call add(names, cname)
                                            if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
                                            let newLoclist = newLoclist.extend(loclist)
                            
                                            if !aggregate_errors
                                                break
                                            endif
                                        endif
    1              0.000001         endfor
                            
                                    " set names {{{3
    1              0.000001         if !empty(names)
                                        if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
                                            let type = substitute(names[0], '\m/.*', '', '')
                                            let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
                                            call newLoclist.setName( name . ' ('. type . ')' )
                                        else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
                                    endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
    1              0.000002         if len(clist) == unavailable_checkers
                                        if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
                                        endif
                                    endif
                                    " }}}3
                            
    1   0.000009   0.000003         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
    1              0.000001         if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
                                    endif
    1              0.000000     endif
                            
    1   0.000091   0.000004     call newLoclist.deploy()

FUNCTION  neocomplete#handler#_on_moved_i()
Called 10 times
Total time:   0.000770
 Self time:   0.000187

count  total (s)   self (s)
   10   0.000134   0.000048   let neocomplete = neocomplete#get_current_neocomplete()
   10              0.000027   if neocomplete.linenr != line('.')
    1   0.000030   0.000004     call neocomplete#helper#clear_result()
    1              0.000001   endif
   10              0.000022   let neocomplete.linenr = line('.')
                            
   10   0.000513   0.000042   call s:close_preview_window()

FUNCTION  114()
Called 72 times
Total time:   0.002086
 Self time:   0.000515

count  total (s)   self (s)
   72   0.002061   0.000490     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  116()
Called 2 times
Total time:   0.000380
 Self time:   0.000015

count  total (s)   self (s)
    2   0.000374   0.000009     if a:path.equals(self.path)
    1              0.000001         return self
                                endif
    1              0.000001     return {}

FUNCTION  119()
Called 426 times
Total time:   0.000580
 Self time:   0.000580

count  total (s)   self (s)
  426              0.000449     return self._nerdtree

FUNCTION  320()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)

FUNCTION  322()
Called 1 time
Total time:   0.000062
 Self time:   0.000019

count  total (s)   self (s)
    2   0.000053   0.000010     for buf in self.getBuffers()
    1              0.000005         call setbufvar(buf, 'syntastic_loclist', {})
    1              0.000001     endfor

FUNCTION  gitgutter#sign#next_sign_id()
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000005   let next_id = s:next_sign_id
    2              0.000005   let s:next_sign_id += 1
    2              0.000001   return next_id

FUNCTION  31()
Called 354 times
Total time:   0.040507
 Self time:   0.014815

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
  354   0.001452   0.000922     if a:nerdtree.ui.isIgnoreFilterEnabled()
 1058              0.001184         for i in g:NERDTreeIgnore
  708   0.019608   0.002270             if self._ignorePatternMatches(i)
    4              0.000005                 return 1
                                        endif
  704              0.000487         endfor
                            
  350   0.003097   0.001103         for callback in g:NERDTree.PathFilters()
                                        if {callback}({'path': self, 'nerdtree': a:nerdtree})
                                            return 1
                                        endif
                                    endfor
  350              0.000211     endif
                            
                                "dont show hidden files unless instructed to
  350   0.007068   0.001630     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
   56              0.000051         return 1
                                endif
                            
  294   0.001330   0.000938     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
                                endif
                            
  294              0.000215     return 0

FUNCTION  32()
Called 708 times
Total time:   0.017338
 Self time:   0.013018

count  total (s)   self (s)
  708              0.001069     let pat = a:pattern
  708              0.002515     if strpart(pat,len(pat)-7) == '[[dir]]'
  354              0.000408         if !self.isDirectory
  244              0.000178             return 0
                                    endif
  110              0.000352         let pat = strpart(pat,0, len(pat)-7)
  110              0.000240     elseif strpart(pat,len(pat)-8) == '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
                                endif
                            
  464   0.007027   0.002707     return self.getLastPathComponent(0) =~# pat

FUNCTION  36()
Called 17 times
Total time:   0.002867
 Self time:   0.000145

count  total (s)   self (s)
   17   0.002862   0.000140     return self.str() ==# a:path.str()

FUNCTION  37()
Called 1 time
Total time:   0.000473
 Self time:   0.000071

count  total (s)   self (s)
    1              0.000038     let newPath = copy(self)
                            
    1   0.000399   0.000015     call newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:path))
                            
    1              0.000003     let newPath.cachedDisplayString = ""
    1   0.000030   0.000012     let newPath.flagSet = g:NERDTreeFlagSet.New()
                            
    1              0.000001     return newPath

FUNCTION  38()
Called 492 times
Total time:   0.004818
 Self time:   0.001484

count  total (s)   self (s)
  492   0.004660   0.001326     return nerdtree#runningWindows() ? '\' : '/'

FUNCTION  39()
Called 2 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    2              0.000031     let tmp = resolve(a:path)
    2              0.000045     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  <SNR>122__isDebugEnabled_smart()
Called 28 times
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
   28              0.000060     return and(g:syntastic_debug, a:level)

FUNCTION  333()
Called 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000003     if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
                                else
    1              0.000006         let self._mode = 'active'
    1              0.000004         let self._activeFiletypes = []
    1              0.000003         let self._passiveFiletypes = []
    1              0.000001     endif

FUNCTION  334()
Called 1 time
Total time:   0.000068
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000024     let fts = split(a:filetype, '\m\.')
                            
    1   0.000010   0.000006     if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
                                else
    1   0.000029   0.000008         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  335()
Called 1 time
Total time:   0.000085
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000005     let local_mode = get(b:, 'syntastic_mode', '')
    1              0.000002     if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
                                endif
                            
    1   0.000076   0.000008     return self.allowsAutoChecking(&filetype)

FUNCTION  336()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004     return self._mode ==# 'passive'

FUNCTION  neocomplete#util#is_text_changed()
Called 10 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
                              " Note: Vim 7.4.143 fixed TextChangedI bug.
   10              0.000060   return v:version > 704 || v:version == 704 && has('patch143')

FUNCTION  neocomplete#util#is_sudo()
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000010   return $SUDO_USER != '' && $USER !=# $SUDO_USER && $HOME !=# expand('~'.$USER) && $HOME ==# expand('~'.$SUDO_USER)

FUNCTION  gitgutter#diff#is_added()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001   return a:from_count == 0 && a:to_count > 0

FUNCTION  40()
Called 1 time
Total time:   0.000317
 Self time:   0.000171

count  total (s)   self (s)
    1   0.000031   0.000006     call self.extractDriveLetter(a:fullpath)
                            
    1   0.000016   0.000005     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
    1              0.000006     if getftype(fullpath) ==# "fifo"
                                    throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
                                endif
                            
    1              0.000019     let self.pathSegments = split(fullpath, '/')
                            
    1              0.000012     let self.isReadOnly = 0
    1              0.000007     if isdirectory(a:fullpath)
                                    let self.isDirectory = 1
                                elseif filereadable(a:fullpath)
    1              0.000002         let self.isDirectory = 0
    1              0.000009         let self.isReadOnly = filewritable(a:fullpath) ==# 0
    1              0.000001     else
                                    throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
                                endif
                            
    1              0.000003     let self.isExecutable = 0
    1              0.000001     if !self.isDirectory
    1              0.000010         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
    1              0.000001     endif
                            
                                "grab the last part of the path (minus the trailing slash)
    1   0.000020   0.000007     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
    1   0.000078   0.000021     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
    1   0.000051   0.000011     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
    1              0.000002     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
                                endif

FUNCTION  42()
Called 72 times
Total time:   0.085228
 Self time:   0.000812

count  total (s)   self (s)
   72   0.081178   0.000484     call g:NERDTreePathNotifier.NotifyListeners('refreshFlags', self, a:nerdtree, {})
   72   0.003952   0.000230     call self.cacheDisplayString()

FUNCTION  44()
Called 212 times
Total time:   0.017058
 Self time:   0.007947

count  total (s)   self (s)
  212              0.000384     let options = a:0 ? a:1 : {}
  212              0.000253     let toReturn = ""
                            
  212              0.000364     if has_key(options, 'format')
    2              0.000004         let format = options['format']
    2              0.000009         if has_key(self, '_strFor' . format)
    2   0.000048   0.000018             exec 'let toReturn = self._strFor' . format . '()'
    2              0.000000         else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
    2              0.000002     else
  210   0.009200   0.000734         let toReturn = self._str()
  210              0.000132     endif
                            
  212   0.001220   0.000605     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
  212              0.000342     if has_key(options, 'truncateTo')
    2              0.000004         let limit = options['truncateTo']
    2              0.000006         if len(toReturn) > limit-1
    2              0.000008             let toReturn = toReturn[(len(toReturn)-limit+1):]
    2              0.000019             if len(split(toReturn, '/')) > 1
    2              0.000021                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
    2              0.000001             else
                                            let toReturn = '<' . toReturn
                                        endif
    2              0.000002         endif
    2              0.000001     endif
                            
  212              0.000205     return toReturn

FUNCTION  45()
Called 2 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000011     let toReturn = '/' . join(self.pathSegments, '/')
    2              0.000005     if self.isDirectory && toReturn != '/'
    2              0.000006         let toReturn  = toReturn . '/'
    2              0.000002     endif
    2              0.000002     return toReturn

FUNCTION  49()
Called 210 times
Total time:   0.008466
 Self time:   0.002961

count  total (s)   self (s)
  210   0.002826   0.000669     let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
  210   0.001864   0.000486     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
  210   0.003070   0.001100     return lead . join(self.pathSegments, s:Path.Slash())

FUNCTION  300()
Called 2 times
Total time:   0.000017
 Self time:   0.000004

count  total (s)   self (s)
    2   0.000017   0.000004     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  131()
Called 47 times
Total time:   0.046432
 Self time:   0.000288

count  total (s)   self (s)
   47   0.046421   0.000277     call self.path.refreshFlags(self.getNerdtree())

FUNCTION  133()
Called 2 times
Total time:   0.054616
 Self time:   0.000019

count  total (s)   self (s)
    2   0.054613   0.000016     return self._renderToString(0, 0)

FUNCTION  134()
Called 108 times
Total time:   0.159523
 Self time:   0.144361

count  total (s)   self (s)
  108              0.000157     let output = ""
  108              0.000118     if a:drawText ==# 1
                            
  106              0.000301         let treeParts = repeat('  ', a:depth - 1)
                            
  106              0.000120         if !self.path.isDirectory
   72              0.000142             let treeParts = treeParts . '  '
   72              0.000047         endif
                            
  106   0.016529   0.000450         let line = treeParts . self.displayString()
                            
  106              0.000237         let output = output . line . "\n"
  106              0.000063     endif
                            
                                "if the node is an open dir, draw its children
  108              0.000141     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
   20   0.017582   0.000086         let childNodesToDraw = self.getVisibleChildren()
                            
   20   0.016232   0.000086         if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
                                    elseif len(childNodesToDraw) > 0
  126              0.000120             for i in childNodesToDraw
  106              0.000415                 let output = output . i._renderToString(a:depth + 1, 1)
  106              0.000071             endfor
   20              0.000011         endif
   20              0.000012     endif
                            
  108              0.000117     return output

FUNCTION  airline#extensions#tabline#get_buffer_name()
Called 442 times
Total time:   2.780866
 Self time:   0.006166

count  total (s)   self (s)
  442   2.780632   0.005932   return airline#extensions#tabline#{s:formatter}#format(a:nr, get(s:, 'current_buffer_list', s:get_buffer_list()))

FUNCTION  341()
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000019     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  343()
Called 1 time
Total time:   0.001114
 Self time:   0.000215

count  total (s)   self (s)
    1   0.000005   0.000003     if !a:loclist.isEmpty() && !a:loclist.isNewerThan([])
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
    1   0.000008   0.000003     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
    6              0.000006     for type in self._enabled_types
    5              0.000036         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
    5   0.000075   0.000036         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
    5              0.000009             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
    2              0.000007                 if !exists('b:syntastic_private_' . type . '_stamp')
                                                let b:syntastic_private_{type}_stamp = []
                                            endif
    2   0.000061   0.000011                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
    2   0.000122   0.000010                     call self._notifier[type].refresh(a:loclist)
    2   0.000033   0.000011                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
    2              0.000001                 endif
    2              0.000001             else
    3   0.000684   0.000015                 call self._notifier[type].refresh(a:loclist)
    3              0.000001             endif
    5              0.000003         endif
    5              0.000002     endfor

FUNCTION  344()
Called 1 time
Total time:   0.001043
 Self time:   0.000203

count  total (s)   self (s)
    1   0.000013   0.000005     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
    6              0.000009     for type in self._enabled_types
    5              0.000049         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
    5              0.000027         if has_key(g:{class}, 'reset')
    3   0.000858   0.000026             call self._notifier[type].reset(a:loclist)
    3              0.000002         endif
                            
                                    " also reset stamps
    5              0.000014         if index(s:_PERSISTENT_NOTIFIERS, type) > -1
    2              0.000020             let b:syntastic_private_{type}_stamp = []
    2              0.000002         endif
    5              0.000004     endfor

FUNCTION  348()
Called 1 time
Total time:   0.000111
 Self time:   0.000054

count  total (s)   self (s)
    1   0.000028   0.000009     let ft = s:_normalise_filetype(a:ftalias)
    1   0.000012   0.000007     call self._loadCheckersFor(ft)
                            
    1              0.000003     let checkers_map = self._checkerMap[ft]
    1              0.000002     if empty(checkers_map)
                                    return []
                                endif
                            
    1   0.000016   0.000005     call self._checkDeprecation(ft)
                            
    1              0.000014     let names = !empty(a:hints_list) ? syntastic#util#unique(a:hints_list) : exists('b:syntastic_checkers') ? b:syntastic_checkers : exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:_DEFAULT_CHECKERS, ft, 0)
                            
    1   0.000031   0.000009     return type(names) == type([]) ? self._filterCheckersByName(checkers_map, names) : [checkers_map[keys(checkers_map)[0]]]

FUNCTION  neocomplete#print_debug()
Called 48 times
Total time:   0.000201
 Self time:   0.000201

count  total (s)   self (s)
   48              0.000066   if g:neocomplete#enable_debug
                                echomsg string(a:expr)
                              endif

FUNCTION  <SNR>145_garbage_collect()
Called 2 times
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
    2              0.000007   for pid in values(s:bg_processes)
                                " Check processes.
                                try
                                  let [cond, _] = s:libcall('vp_waitpid', [pid])
                                  " echomsg string([pid, cond, _])
                                  if cond !=# 'run' || a:is_force
                                    if cond !=# 'exit'
                                      " Kill process.
                                      call vimproc#kill(pid, g:vimproc#SIGTERM)
                                    endif
                            
                                    if vimproc#util#is_windows()
                                      call s:libcall('vp_close_handle', [pid])
                                    endif
                                    call remove(s:bg_processes, pid)
                                  endif
                                catch
                                  " Ignore error.
                                endtry
                              endfor

FUNCTION  gitgutter#diff#parse_diff()
Called 3 times
Total time:   0.000225
 Self time:   0.000160

count  total (s)   self (s)
    3              0.000019   let hunks = []
    4              0.000067   for line in split(a:diff, '\n')
    1   0.000088   0.000023     let hunk_info = gitgutter#diff#parse_hunk(line)
    1              0.000001     if len(hunk_info) == 4
    1              0.000003       call add(hunks, hunk_info)
    1              0.000001     endif
    1              0.000000   endfor
    3              0.000004   return hunks

FUNCTION  gitgutter#diff#is_modified()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  50()
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000008     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  52()
Called 1 time
Total time:   0.000011
 Self time:   0.000004

count  total (s)   self (s)
    1   0.000009   0.000002     if !nerdtree#runningWindows()
    1              0.000001         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', "g")
                            
                                return toReturn

FUNCTION  <SNR>185_close_preview_window()
Called 12 times
Total time:   0.000571
 Self time:   0.000159

count  total (s)   self (s)
   12   0.000528   0.000116   if g:neocomplete#enable_auto_close_preview && bufname('%') !=# '[Command Line]' && winnr('$') != 1 && !&l:previewwindow && !neocomplete#is_cache_disabled()
                                " Close preview window.
   12              0.000012     pclose!
   12              0.000008   endif

FUNCTION  141()
Called 34 times
Total time:   0.013993
 Self time:   0.000888

count  total (s)   self (s)
   34   0.012530   0.000136     let cascade = self.getCascade()
   34              0.000037     let rv = ""
   68              0.000079     for node in cascade
   34   0.000312   0.000128         let rv = rv . node.path.displayString()
   34              0.000018     endfor
                            
   34              0.000104     let sym = cascade[-1].isOpen ? g:NERDTreeDirArrowCollapsible : g:NERDTreeDirArrowExpandable
                            
   34   0.000669   0.000142     let flags = cascade[-1].path.flagSet.renderToString()
                            
   34              0.000079     return sym . ' ' . flags . rv

FUNCTION  142()
Called 15 times
Total time:   0.015749
 Self time:   0.001596

count  total (s)   self (s)
   15   0.002578   0.000076     if a:path.equals(self.path)
                                    return self
                                endif
   15   0.002519   0.000105     if stridx(a:path.str(), self.path.str(), 0) ==# -1
   12              0.000010         return {}
                                endif
                            
    3              0.000004     if self.path.isDirectory
   16              0.000032         for i in self.children
   16   0.000435   0.000055             let retVal = i.findNode(a:path)
   16              0.000020             if retVal != {}
    3              0.000004                 return retVal
                                        endif
   13              0.000012         endfor
                                endif
                                return {}

FUNCTION  143()
Called 34 times
Total time:   0.012394
 Self time:   0.000773

count  total (s)   self (s)
                            
   34              0.000053     let rv = [self]
   34              0.000041     let node = self
                            
   34              0.000033     while 1
   34   0.011748   0.000127         let vc = node.getVisibleChildren()
   34              0.000046         if len(vc) != 1
   34              0.000027             break
                                    endif
                            
                                    let visChild = vc[0]
                            
                                    "TODO: optimize
                                    if !visChild.path.isDirectory
                                        break
                                    endif
                            
                                    call add(rv, visChild)
                                    let node = visChild
                                endwhile
                            
   34              0.000028     return rv

FUNCTION  gitgutter#diff#process_hunks()
Called 3 times
Total time:   0.000250
 Self time:   0.000071

count  total (s)   self (s)
    3   0.000069   0.000020   call gitgutter#hunk#reset()
    3              0.000007   let modified_lines = []
    4              0.000005   for hunk in a:hunks
    1   0.000145   0.000015     call extend(modified_lines, gitgutter#diff#process_hunk(hunk))
    1              0.000001   endfor
    3              0.000002   return modified_lines

FUNCTION  356()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000003     if has_key(self._checkerMap, a:filetype)
    1              0.000001         return
                                endif
                            
                                execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
                                if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
                                endif

FUNCTION  357()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000006     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers')
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
                                endif

FUNCTION  359()
Called 2 times
Total time:   0.000021
 Self time:   0.000009

count  total (s)   self (s)
    2   0.000020   0.000008     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  gitgutter#sign#add_dummy_sign()
Called 1 time
Total time:   0.013554
 Self time:   0.013552

count  total (s)   self (s)
    1   0.000008   0.000006   let bufnr = gitgutter#utility#bufnr()
    1              0.000003   if !getbufvar(bufnr, 'gitgutter_dummy_sign')
    1              0.013516     execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
    1              0.000021     call setbufvar(bufnr, 'gitgutter_dummy_sign', 1)
    1              0.000002   endif

FUNCTION  gitgutter#utility#filename()
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000006   return fnamemodify(s:file, ':t')

FUNCTION  <SNR>182_get_candidates()
Called 2 times
Total time:   0.000137
 Self time:   0.000137

count  total (s)   self (s)
                              " Append prefix.
    2              0.000002   let candidates = []
    4              0.000007   for result in values(a:complete_results)
    2              0.000003     if result.complete_pos > a:complete_pos
                                  let prefix = a:complete_str[: result.complete_pos                            - a:complete_pos - 1]
                            
                                  for keyword in result.candidates
                                    let keyword.word = prefix . keyword.word
                                  endfor
                                endif
                            
    2              0.000088     let candidates += result.candidates
    2              0.000002   endfor
                            
    2              0.000001   return candidates

FUNCTION  434()
Called 2 times
Total time:   0.000073
 Self time:   0.000033

count  total (s)   self (s)
    2   0.000056   0.000016   call self.load()
    2              0.000010   let index = index(self.candidates, a:path)
    2              0.000003   if index == 0
    2              0.000001     return
                              endif
                            
                              if index > 0
                                call remove(self.candidates, index)
                              endif
                              call insert(self.candidates, a:path)
                            
                              if len(self.candidates) > self.limit
                                let self.candidates = self.candidates[: self.limit - 1]
                              endif
                            
                              if localtime() > getftime(self.mru_file) + self.update_interval
                                call self.save()
                              endif

FUNCTION  <SNR>114_get_buffers()
Called 38 times
Total time:   0.914806
 Self time:   0.002499

count  total (s)   self (s)
   38              0.000129   let cur = bufnr('%')
   38              0.000072   if cur == s:current_bufnr
   38              0.000217     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
   32              0.000086       return s:current_tabline
                                endif
    6              0.000003   endif
                            
    6              0.000007   let l:index = 1
    6   0.000401   0.000032   let b = s:new_builder()
    6              0.000020   let tab_bufs = tabpagebuflist(tabpagenr())
   60   0.895826   0.000081   for nr in s:get_visible_buffers()
   54              0.000041     if nr < 0
    6   0.000037   0.000018       call b.add_raw('%#airline_tabhid#...')
    6              0.000006       continue
                                endif
                            
   48              0.000035     if cur == nr
    6              0.000017       if g:airline_detect_modified && getbufvar(nr, '&modified')
    3              0.000004         let group = 'airline_tabmod'
    3              0.000001       else
    3              0.000006         let group = 'airline_tabsel'
    3              0.000001       endif
    6              0.000017       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
    6              0.000003     else
   42              0.000088       if g:airline_detect_modified && getbufvar(nr, '&modified')
                                    let group = 'airline_tabmod_unsel'
                                  elseif index(tab_bufs, nr) > -1
                                    let group = 'airline_tab'
                                  else
   42              0.000045         let group = 'airline_tabhid'
   42              0.000021       endif
   42              0.000016     endif
                            
   48              0.000036     if s:buffer_idx_mode
                                  if len(s:number_map) > 0
                                    call b.add_section(group, s:spc . get(s:number_map, l:index, '') . '%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)' . s:spc)
                                  else
                                    call b.add_section(group, '['.l:index.s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)'.']')
                                  endif
                                  let l:index = l:index + 1
                                else
   48   0.000360   0.000229       call b.add_section(group, s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)'.s:spc)
   48              0.000022     endif
   48              0.000021   endfor
                            
    6   0.000031   0.000015   call b.add_section('airline_tabfill', '')
    6   0.000036   0.000014   call b.split()
    6   0.000028   0.000011   call b.add_section('airline_tabfill', '')
    6   0.000030   0.000012   call b.add_section('airline_tabtype', ' buffers ')
                            
    6              0.000007   let s:current_bufnr = cur
    6   0.016006   0.000036   let s:current_tabline = b.build()
    6              0.000010   return s:current_tabline

FUNCTION  <SNR>82__skip_file()
Called 2 times
Total time:   0.000220
 Self time:   0.000125

count  total (s)   self (s)
    2              0.000006     let fname = expand('%', 1)
    2   0.000196   0.000101     let skip = s:_is_quitting(bufnr('%')) || get(b:, 'syntastic_skip_checks', 0) || (&buftype !=# '') || !filereadable(fname) || getwinvar(0, '&diff') || getwinvar(0, '&previewwindow') || s:_ignore_file(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
    2              0.000002     if skip
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
                                endif
    2              0.000002     return skip

FUNCTION  151()
Called 74 times
Total time:   0.045121
 Self time:   0.004143

count  total (s)   self (s)
   74              0.000095     let toReturn = []
  428              0.000493     for i in self.children
  354   0.042740   0.001762         if i.path.ignore(self.getNerdtree()) ==# 0
  294              0.000606             call add(toReturn, i)
  294              0.000200         endif
  354              0.000220     endfor
   74              0.000058     return toReturn

FUNCTION  153()
Called 20 times
Total time:   0.016146
 Self time:   0.000142

count  total (s)   self (s)
   20   0.016092   0.000088     let c = self.getVisibleChildren()
   20              0.000039     return len(c) == 1 && c[0].path.isDirectory

FUNCTION  274()
Called 1 time
Total time:   0.000021
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000001     unlet! b:syntastic_private_balloons
    1   0.000014   0.000004     if self.enabled() && !a:loclist.isEmpty()
                                    let b:syntastic_private_balloons = a:loclist.balloons()
                                    if !empty(b:syntastic_private_balloons)
                                        set ballooneval balloonexpr=SyntasticBalloonsExprNotifier()
                                    endif
                                endif

FUNCTION  360()
Called 1 time
Total time:   0.000091
 Self time:   0.000023

count  total (s)   self (s)
    1   0.000008   0.000002     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
    1   0.000012   0.000006     let old_signs = copy(self._bufSignIds())
    1   0.000011   0.000001     if self.enabled()
    1   0.000042   0.000007         call self._signErrors(a:loclist)
    1              0.000000     endif
    1   0.000016   0.000005     call self._removeSigns(old_signs)

FUNCTION  362()
Called 1 time
Total time:   0.000035
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000001     let loclist = a:loclist
    1   0.000004   0.000003     if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
                                endif

FUNCTION  363()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000002     if has('signs')
    1              0.000003         for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
                                    endfor
    1              0.000000     endif

FUNCTION  369()
Called 6 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    6              0.000015   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  neocomplete#get_current_neocomplete()
Called 1730 times
Total time:   0.010153
 Self time:   0.010153

count  total (s)   self (s)
 1730              0.003617   if !exists('b:neocomplete')
                                call neocomplete#init#_current_neocomplete()
                              endif
                            
 1730              0.001650   return b:neocomplete

FUNCTION  neocomplete#util#has_vimproc()
Called 2 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
                              " Initialize.
    2              0.000008   if !exists('g:neocomplete#use_vimproc')
                                " Check vimproc.
                                try
                                  call vimproc#version()
                                  let exists_vimproc = 1
                                catch
                                  let exists_vimproc = 0
                                endtry
                            
                                let g:neocomplete#use_vimproc = exists_vimproc
                              endif
                            
    2              0.000003   return g:neocomplete#use_vimproc

FUNCTION  <SNR>56_CursorHoldUpdate()
Called 1 time
Total time:   0.087565
 Self time:   0.000178

count  total (s)   self (s)
    1              0.000005     if g:NERDTreeUpdateOnCursorHold != 1
                                    return
                                endif
                            
    1   0.000358   0.000011     if !g:NERDTree.IsOpen()
                                    return
                                endif
                            
    1              0.000005     let l:winnr = winnr()
    1   0.000769   0.000006     call g:NERDTree.CursorToTreeWin()
    1   0.055527   0.000013     call b:NERDTreeRoot.refreshFlags()
    1   0.030773   0.000010     call NERDTreeRender()
    1              0.000115     exec l:winnr . 'wincmd w'

FUNCTION  NERDTreeRender()
Called 2 times
Total time:   0.055754
 Self time:   0.000016

count  total (s)   self (s)
    2   0.055752   0.000014     call nerdtree#renderView()

FUNCTION  164()
Called 22 times
Total time:   0.107408
 Self time:   0.055140

count  total (s)   self (s)
   22   0.037924   0.000150     call self.path.refreshFlags(self.getNerdtree())
   89              0.000198     for i in self.children
   67   0.017236   0.000182         call i.refreshFlags()
   67              0.000047     endfor

FUNCTION  165()
Called 3 times
Total time:   0.001441
 Self time:   0.000022

count  total (s)   self (s)
    3   0.001439   0.000020     call self.path.refreshFlags(self.getNerdtree())

FUNCTION  <SNR>119_get_transitioned_seperator()
Called 18 times
Total time:   0.005545
 Self time:   0.000316

count  total (s)   self (s)
   18              0.000023   let line = ''
   18   0.005309   0.000080   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   18              0.000088   let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   18              0.000054   let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   18              0.000038   let line .= '%#'.a:group.'#'
   18              0.000015   return line

FUNCTION  airline#highlighter#add_separator()
Called 18 times
Total time:   0.005229
 Self time:   0.000289

count  total (s)   self (s)
   18              0.000131   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   18   0.005090   0.000150   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  371()
Called 66 times
Total time:   0.000182
 Self time:   0.000182

count  total (s)   self (s)
   66              0.000162   call add(self._sections, [a:group, a:contents])

FUNCTION  372()
Called 6 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    6              0.000015   call add(self._sections, ['', a:text])

FUNCTION  373()
Called 6 times
Total time:   0.015970
 Self time:   0.002888

count  total (s)   self (s)
    6              0.000008   let side = 1
    6              0.000006   let line = ''
    6              0.000005   let i = 0
    6              0.000011   let length = len(self._sections)
    6              0.000006   let split = 0
                            
   84              0.000084   while i < length
   78              0.000135     let section = self._sections[i]
   78              0.000117     let group = section[0]
   78              0.000118     let contents = section[1]
   78   0.000997   0.000271     let prev_group = s:get_prev_group(self._sections, i)
                            
   78              0.000075     if group == ''
    6              0.000011       let line .= contents
    6              0.000006     elseif group == '|'
    6              0.000006       let side = 0
    6              0.000008       let line .= contents
    6              0.000005       let split = 1
    6              0.000005     else
   66              0.000068       if prev_group == ''
    6              0.000014         let line .= '%#'.group.'#'
    6              0.000005       elseif split
    6   0.001837   0.000035         let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    6              0.000007         let split = 0
    6              0.000004       else
   54   0.008606   0.000239         let line .= s:get_seperator(self, prev_group, group, side)
   54              0.000038       endif
   66   0.002568   0.000381       let line .= s:get_accented_line(self, group, contents)
   66              0.000032     endif
                            
   78              0.000107     let i = i + 1
   78              0.000041   endwhile
                            
    6              0.000007   if !self._context.active
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
                              endif
    6              0.000006   return line

FUNCTION  syntastic#log#deprecationWarn()
Called 1 time
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000005     if exists('g:syntastic_' . a:old) && !exists('g:syntastic_' . a:new)
                                    let msg = 'variable g:syntastic_' . a:old . ' is deprecated, please use '
                            
                                    if a:0
                                        let OLD_VAR = g:syntastic_{a:old}
                                        try
                                            let NEW_VAR = eval(a:1)
                                            let msg .= 'in its stead: let g:syntastic_' . a:new . ' = ' . string(NEW_VAR)
                                            let g:syntastic_{a:new} = NEW_VAR
                                        catch
                                            let msg .= 'g:syntastic_' . a:new . ' instead'
                                        endtry
                                    else
                                        let msg .= 'g:syntastic_' . a:new . ' instead'
                                        let g:syntastic_{a:new} = g:syntastic_{a:old}
                                    endif
                            
                                    call syntastic#log#oneTimeWarn(msg)
                                endif

FUNCTION  <SNR>185_check_force_omni()
Called 11 times
Total time:   0.001008
 Self time:   0.000188

count  total (s)   self (s)
   11              0.000022   let cur_text = a:cur_text
   11   0.000884   0.000064   let complete_pos = neocomplete#helper#get_force_omni_complete_pos(cur_text)
                            
   11              0.000031   if complete_pos >= 0 && !neocomplete#complete#_check_previous_position(       cur_text, complete_pos)
                                call s:complete_key("\<Plug>(neocomplete_start_omni_complete)")
                              endif
                            
   11              0.000014   return complete_pos

FUNCTION  <SNR>145_vp_pipe_close()
Called 2 times
Total time:   0.000343
 Self time:   0.000018

count  total (s)   self (s)
                              " echomsg 'close:'.self.fd
    2              0.000002   if self.fd != 0
    2   0.000335   0.000010     call s:libcall('vp_pipe_close', [self.fd])
    2              0.000002     let self.fd = 0
    2              0.000002   endif

FUNCTION  85()
Called 72 times
Total time:   0.000440
 Self time:   0.000440

count  total (s)   self (s)
   72              0.000199     if !exists("g:NERDTreeBookmarks")
                                    let g:NERDTreeBookmarks = []
                                endif
   72              0.000067     return g:NERDTreeBookmarks

FUNCTION  gitgutter#utility#set_buffer()
Called 4 times
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
    4              0.000012   let s:bufnr = a:bufnr
    4              0.000102   let s:file = resolve(bufname(a:bufnr))

FUNCTION  syntastic#util#system()
Called 1 time
Total time:   0.223024
 Self time:   0.000261

count  total (s)   self (s)
    1              0.000002     let old_shell = &shell
    1              0.000002     let old_lc_messages = $LC_MESSAGES
    1              0.000003     let old_lc_all = $LC_ALL
                            
    1   0.000018   0.000009     let &shell = syntastic#util#var('shell')
    1              0.000003     let $LC_MESSAGES = 'C'
    1              0.000003     let $LC_ALL = ''
                            
    1   0.222953   0.000199     let out = system(a:command)
                            
    1              0.000010     let $LC_ALL = old_lc_all
    1              0.000004     let $LC_MESSAGES = old_lc_messages
                            
    1              0.000015     let &shell = old_shell
                            
    1              0.000003     return out

FUNCTION  neocomplete#sources#buffer#make_cache_current_line()
Called 6 times
Total time:   0.015137
 Self time:   0.000139

count  total (s)   self (s)
    6   0.000243   0.000021   if neocomplete#is_locked()
                                return
                              endif
                            
                              " let start = reltime()
    6   0.014871   0.000095   call s:make_cache_current_buffer( max([1, line('.') - winline()]), min([line('$'), line('.') + winheight(0) - winline()]))
                              " echomsg reltimestr(reltime(start))

FUNCTION  airline#util#wrap()
Called 597 times
Total time:   0.002562
 Self time:   0.002562

count  total (s)   self (s)
  597              0.001056   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  597              0.000513   return a:text

FUNCTION  neocomplete#within_comment()
Called 3 times
Total time:   0.000032
 Self time:   0.000012

count  total (s)   self (s)
    3   0.000029   0.000009   return neocomplete#get_current_neocomplete().within_comment

FUNCTION  gitgutter#utility#help_file()
Called 3 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    3              0.000016   return getbufvar(s:bufnr, '&filetype') ==# 'help' && getbufvar(s:bufnr, '&buftype') ==# 'help'

FUNCTION  <SNR>145_fdopen_pgroup()
Called 3 times
Total time:   0.000216
 Self time:   0.000056

count  total (s)   self (s)
    3   0.000213   0.000053   return { 'eof' : 0, '__eof' : 0, 'is_valid' : 1, 'buffer' : [], 'proc' : a:proc, 'fd' : a:fd, 'f_close' : s:funcref(a:f_close), 'close' : s:funcref('close'), 'read' : s:funcref(a:f_read), 'write' : s:funcref(a:f_write), 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),}

FUNCTION  <SNR>145_fdopen_pipes()
Called 3 times
Total time:   0.000241
 Self time:   0.000057

count  total (s)   self (s)
    3   0.000240   0.000056   return { 'eof' : 0, '__eof' : 0, 'is_valid' : 1, 'buffer' : [], 'fd' : a:fd, 'f_close' : s:funcref(a:f_close), 'close' : s:funcref('close'), 'read' : s:funcref(a:f_read), 'write' : s:funcref(a:f_write), 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),}

FUNCTION  syntastic#log#debugShowVariables()
Called 2 times
Total time:   0.000021
 Self time:   0.000013

count  total (s)   self (s)
    2   0.000015   0.000007     if !s:_isDebugEnabled(a:level)
    2              0.000000         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)

FUNCTION  airline#extensions#tabline#get()
Called 38 times
Total time:   0.915671
 Self time:   0.000865

count  total (s)   self (s)
   38              0.000193   let curtabcnt = tabpagenr('$')
   38              0.000091   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                let s:current_bufnr = -1  " force a refresh...
                              endif
   38              0.000075   if s:show_buffers && curtabcnt == 1
   38   0.915094   0.000288     return s:get_buffers()
                              else
                                return s:get_tabs()
                              endif

FUNCTION  neocomplete#cache#encode_name()
Called 4 times
Total time:   0.000837
 Self time:   0.000077

count  total (s)   self (s)
                              " Check cache directory.
    4   0.000483   0.000042   let cache_dir = neocomplete#get_data_directory() . '/' . a:cache_dir
    4   0.000351   0.000032   return s:Cache.getfilename(cache_dir, a:filename)

FUNCTION  vimproc#get_command_name()
Called 1 time
Total time:   0.000097
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000003   let path = get(a:000, 0, $PATH)
                            
    1              0.000003   let cnt = a:0 < 2 ? 1 : a:2
                            
    1   0.000078   0.000022   let files = split(substitute(vimproc#util#substitute_path_separator( vimproc#filepath#which(a:command, path, cnt)), '//', '/', 'g'), '\n')
                            
    1              0.000001   if cnt < 0
                                return files
                              endif
                            
    1              0.000002   let file = get(files, cnt-1, '')
                            
    1              0.000001   if file == ''
                                throw printf( 'vimproc#get_command_name: File "%s" is not found.', a:command)
                              endif
                            
    1              0.000001   return file

FUNCTION  <SNR>68_sub()
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000016   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  neocomplete#is_eskk_enabled()
Called 21 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
   21              0.000076   return exists('*eskk#is_enabled') && eskk#is_enabled()

FUNCTION  <SNR>145_funcref()
Called 67 times
Total time:   0.000926
 Self time:   0.000331

count  total (s)   self (s)
   67   0.000896   0.000301   return function(s:SID_PREFIX().a:funcname)

FUNCTION  <SNR>181_make_cache_lines()
Called 7 times
Total time:   0.004025
 Self time:   0.003984

count  total (s)   self (s)
    7              0.000013   let filetype = a:filetype
    7              0.000017   if !has_key(s:member_sources, a:srcname)
                                call s:initialize_source(a:srcname, filetype)
                              endif
                            
    7              0.000040   let prefix = get(g:neocomplete#sources#member#prefix_patterns, filetype, get(g:neocomplete#sources#member#prefix_patterns, '_', ''))
    7              0.000008   if prefix == ''
                                return
                              endif
    7              0.000019   let source = s:member_sources[a:srcname]
    7   0.000077   0.000036   let member_pattern = s:get_member_pattern(filetype)
    7              0.000040   let prefix_pattern = member_pattern . '\m\%(' . prefix . '\m\)'
    7              0.000017   let keyword_pattern = prefix_pattern . member_pattern
                            
                              " Cache member pattern.
   46              0.000047   for line in a:lines
   39              0.000368     let match = match(line, keyword_pattern)
                            
  100              0.000082     while match >= 0 "{{{
   61              0.000531       let match_str = matchstr(line, '^'.keyword_pattern, match)
                            
                                  " Next match.
   61              0.000397       let match = matchend(line, prefix_pattern, match)
                            
   61              0.000409       let member_name = matchstr(match_str, member_pattern . '$')
   61              0.000095       if member_name == ''
   22              0.000017         continue
                                  endif
   39              0.000127       let var_name = match_str[ : -len(member_name)-1]
                            
   39              0.000076       if !has_key(source.member_cache, var_name)
                                    let source.member_cache[var_name] = {}
                                  endif
   39              0.000102       if !has_key(source.member_cache[var_name], member_name)
    2              0.000005         let source.member_cache[var_name][member_name] = 1
    2              0.000001       endif
                            
   39              0.000295       let match_str = matchstr(var_name, '^'.keyword_pattern)
   39              0.000031     endwhile"}}}
   39              0.000025   endfor

FUNCTION  gitgutter#hunk#hunks()
Called 3 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    3              0.000006   return s:hunks

FUNCTION  neocomplete#mappings#close_popup()
Called 6 times
Total time:   0.000777
 Self time:   0.000175

count  total (s)   self (s)
    6   0.000071   0.000028   let neocomplete = neocomplete#get_current_neocomplete()
    6              0.000022   let neocomplete.complete_str = ''
    6   0.000590   0.000031   let neocomplete.old_cur_text = neocomplete#get_cur_text(1)
    6              0.000012   let neocomplete.skip_next_complete = 1
                            
    6              0.000018   return pumvisible() ? "\<C-y>" : ''

FUNCTION  neocomplete#helper#clear_result()
Called 15 times
Total time:   0.000495
 Self time:   0.000400

count  total (s)   self (s)
   15   0.000149   0.000054   let neocomplete = neocomplete#get_current_neocomplete()
                            
   15              0.000046   let neocomplete.complete_str = ''
   15              0.000079   let neocomplete.candidates = []
   15              0.000043   let neocomplete.complete_sources = []
   15              0.000018   let neocomplete.complete_pos = -1
                            
                              " Restore completeopt.
   15              0.000042   if neocomplete.completeopt !=# &completeopt
                                " Restore completeopt.
    7              0.000041     let &completeopt = neocomplete.completeopt
    7              0.000006   endif

FUNCTION  <SNR>181_get_member_list()
Called 2 times
Total time:   0.000326
 Self time:   0.000093

count  total (s)   self (s)
    2              0.000003   let keyword_list = []
    8   0.000285   0.000052   for source in filter(s:get_sources_list(a:context), 'has_key(v:val.member_cache, a:var_name)')
    6              0.000027     let keyword_list += keys(source.member_cache[a:var_name])
    6              0.000002   endfor
                            
    2              0.000001   return keyword_list

FUNCTION  <SNR>164_get_prelude()
Called 15 times
Total time:   0.000119
 Self time:   0.000119

count  total (s)   self (s)
   15              0.000038   if !exists('s:Prelude')
                                let s:Prelude = neocomplete#util#get_vital().import('Prelude')
                              endif
   15              0.000014   return s:Prelude

FUNCTION  <SNR>157_is_file_exist()
Called 1 time
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
    1              0.000056   let ignore = !empty(g:neomru#file_mru_ignore_pattern) && a:path =~ g:neomru#file_mru_ignore_pattern
    1              0.000009   return !ignore && (getftype(a:path) ==# 'file' || a:path =~ '^\h\w\+:')

FUNCTION  <SNR>182_get_omni_list()
Called 2 times
Total time:   0.007168
 Self time:   0.007168

count  total (s)   self (s)
    2              0.000003   let omni_list = []
                            
                              " Convert string list.
 1108              0.001009   for val in deepcopy(a:list)
 1106              0.002966     let dict = (type(val) == type('') ? { 'word' : val } : val)
 1106              0.001499     call add(omni_list, dict)
                            
 1106              0.000653     unlet val
 1106              0.000466   endfor
                            
    2              0.000003   return omni_list

FUNCTION  gitgutter#hunk#increment_lines_modified()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   let s:summary[1] += a:count

FUNCTION  gitgutter#diff#process_modified_and_added()
Called 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    1              0.000001   let offset = 0
    2              0.000004   while offset < a:from_count
    1              0.000002     let line_number = a:to_line + offset
    1              0.000006     call add(a:modifications, [line_number, 'modified'])
    1              0.000001     let offset += 1
    1              0.000001   endwhile
    2              0.000002   while offset < a:to_count
    1              0.000002     let line_number = a:to_line + offset
    1              0.000002     call add(a:modifications, [line_number, 'added'])
    1              0.000001     let offset += 1
    1              0.000001   endwhile

FUNCTION  430()
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000015   return self.mtime < getftime(self.mru_file)

FUNCTION  gitgutter#hunk#increment_lines_added()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   let s:summary[0] += a:count

FUNCTION  <SNR>68_repo_head()
Called 1 time
Total time:   0.000134
 Self time:   0.000033

count  total (s)   self (s)
    1   0.000093   0.000010     let head = s:repo().head_ref()
                            
    1              0.000006     if head =~# '^ref: '
    1   0.000027   0.000009       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
    1              0.000001     elseif head =~# '^\x\{40\}$'
                                  " truncate hash to a:1 characters if we're in detached head mode
                                  let len = a:0 ? a:1 : 0
                                  let branch = len ? head[0:len-1] : ''
                                else
                                  return ''
                                endif
                            
    1              0.000001     return branch

FUNCTION  AutoPairsReturn()
Called 1 time
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000003   if b:autopairs_enabled == 0
                                return ''
                              end
    1              0.000003   let line = getline('.')
    1              0.000004   let pline = getline(line('.')-1)
    1              0.000004   let prev_char = pline[strlen(pline)-1]
    1              0.000001   let cmd = ''
    1              0.000003   let cur_char = line[col('.')-1]
    1              0.000005   if has_key(b:AutoPairs, prev_char) && b:AutoPairs[prev_char] == cur_char
                                if g:AutoPairsCenterLine && winline() * 3 >= winheight(0) * 2
                                  " Use \<BS> instead of \<ESC>cl will cause the placeholder deleted
                                  " incorrect. because <C-O>zz won't leave Normal mode.
                                  " Use \<DEL> is a bit wierd. the character before cursor need to be deleted.
                                  let cmd = " \<C-O>zz\<ESC>cl"
                                end
                            
                                " If equalprg has been set, then avoid call =
                                " https://github.com/jiangmiao/auto-pairs/issues/24
                                if &equalprg != ''
                                  return "\<ESC>O".cmd
                                endif
                            
                                " conflict with javascript and coffee
                                " javascript   need   indent new line
                                " coffeescript forbid indent new line
                                if &filetype == 'coffeescript' || &filetype == 'coffee'
                                  return "\<ESC>k==o".cmd
                                else
                                  return "\<ESC>=ko".cmd
                                endif
                              end
    1              0.000001   return ''

FUNCTION  neocomplete#filters#converter_remove_overlap#length()
Called 1174 times
Total time:   0.059841
 Self time:   0.059841

count  total (s)   self (s)
 1174              0.002048   if a:left == '' || a:right == ''
                                return 0
                              endif
                            
 1174              0.001099   let ret = 0
                            
 1174              0.000780   lua << EOF
                            do
                              local ret = vim.eval('ret')
                              local left = vim.eval('a:left')
                              local right = vim.eval('a:right')
                              local left_len = string.len(left)
                              local right_len = string.len(right)
                            
                              if left_len > right_len then
                                left = string.sub(left, left_len-right_len, left_len)
                              elseif left_len < right_len then
                                right = string.sub(right, 0, left_len)
                              end
                            
                              if left == right then
                                ret = math.min(left_len, right_len)
                              else
                                local length = 1
                                left_len = string.len(left)
                                while 1 do
                                  local pattern = string.sub(left, left_len-length+1, left_len)
                                  local pos = string.find(right, pattern, 1, 1)
                                  if pos == nil then
                                    break
                                  end
                                  length = length + pos - 1
                                  if string.sub(left, left_len-length+1, left_len) ==
                                    string.sub(right, 1, length) then
                                    ret = length
                                    length = length + 1
                                  end
                                end
                              end
                              vim.command('let ret = ' .. ret)
                            end
                            EOF
                            
 1174              0.000913   return ret

FUNCTION  neocomplete#has_vimproc()
Called 2 times
Total time:   0.000052
 Self time:   0.000019

count  total (s)   self (s)
    2   0.000050   0.000017   return neocomplete#util#has_vimproc()

FUNCTION  syntastic#util#compareLexi()
Called 2 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    2              0.000008     for idx in range(max([len(a:a), len(a:b)]))
    2              0.000006         let a_element = str2nr(get(a:a, idx, 0))
    2              0.000007         let b_element = str2nr(get(a:b, idx, 0))
    2              0.000003         if a_element != b_element
    2              0.000003             return a_element > b_element ? 1 : -1
                                    endif
                                endfor
                                " still here, thus everything matched
                                return 0

FUNCTION  <SNR>119_get_prev_group()
Called 78 times
Total time:   0.000726
 Self time:   0.000726

count  total (s)   self (s)
   78              0.000112   let x = a:i - 1
   90              0.000093   while x >= 0
   84              0.000153     let group = a:sections[x][0]
   84              0.000141     if group != '' && group != '|'
   72              0.000058       return group
                                endif
   12              0.000014     let x = x - 1
   12              0.000007   endwhile
    6              0.000003   return ''

FUNCTION  neocomplete#helper#call_filters()
Called 31 times
Total time:   0.115614
 Self time:   0.001592

count  total (s)   self (s)
   31              0.000083   let context = extend(a:source.neocomplete__context, a:context)
   93              0.000107   for filter in a:filters
   62              0.000042     try
   62   0.114413   0.000391       let context.candidates = call(filter.filter, [context], filter)
   62              0.000051     catch
                                  call neocomplete#print_error(v:throwpoint)
                                  call neocomplete#print_error(v:exception)
                                  call neocomplete#print_error( 'Error occurred in calling filter '   . filter.name . '!')
                                  call neocomplete#print_error( 'Source name is ' . a:source.name)
                                endtry
   62              0.000036   endfor
                            
   31              0.000033   return context.candidates

FUNCTION  nerdtree#runningWindows()
Called 777 times
Total time:   0.005181
 Self time:   0.005181

count  total (s)   self (s)
  777              0.004925     return has("win16") || has("win32") || has("win64")

FUNCTION  javascriptcomplete#CompleteJS()
Called 4 times
Total time:   0.011747
 Self time:   0.011747

count  total (s)   self (s)
    4              0.000004   if a:findstart
                            	" locate the start of the word
    2              0.000005 	let line = getline('.')
    2              0.000004 	let start = col('.') - 1
    2              0.000002 	let curline = line('.')
    2              0.000004 	let compl_begin = col('.') - 2
                            	" Bit risky but JS is rather limited language and local chars shouldn't
                            	" fint way into names
    2              0.000010 	while start >= 0 && line[start - 1] =~ '\k'
                            		let start -= 1
                            	endwhile
    2              0.000010 	let b:compl_context = getline('.')[0:compl_begin]
    2              0.000002 	return start
                              else
                            	" Initialize base return lists
    2              0.000002 	let res = []
    2              0.000003 	let res2 = []
                            	" a:base is very short - we need context
                            	" Shortcontext is context without a:base, useful for checking if we are
                            	" looking for objects and for what objects we are looking for
    2              0.000003 	let context = b:compl_context
    2              0.000012 	let shortcontext = substitute(context, a:base.'$', '', '')
    2              0.000004 	unlet! b:compl_context
                            
    2              0.000004 	if exists("b:jsrange")
                            		let file = getline(b:jsrange[0],b:jsrange[1])
                            		unlet! b:jsrange
                            
                            		if len(b:js_extfiles) > 0
                            			let file = b:js_extfiles + file
                            		endif
                            
                            	else
    2              0.000019 		let file = getline(1, '$')
    2              0.000002 	endif
                            
                            
                            	" Completion of properties, methods, etc. {{{
    2              0.000008 	if shortcontext =~ '\.$'
                            		" Complete methods and properties for objects
                            		" DOM separate
    2              0.000011 		let doms = ['style.']
                            		" Arrays
    2              0.000006 		let arrayprop = ['constructor', 'index', 'input', 'length', 'prototype']
    2              0.000010 		let arraymeth = ['concat', 'join', 'pop', 'push', 'reverse', 'shift', 'splice', 'sort', 'toSource', 'toString', 'unshift', 'valueOf', 'watch', 'unwatch']
    2              0.000034 		call map(arraymeth, 'v:val."("')
    2              0.000012 		let arrays = arrayprop + arraymeth
                            
                            		" Boolean - complete subset of array values
                            		" properties - constructor, prototype
                            		" methods    - toSource, toString, valueOf
                            
                            		" Date
                            		" properties - constructor, prototype
    2              0.000048 		let datemeth = ['getDate', 'getDay', 'getFullYear', 'getHours', 'getMilliseconds', 'getMinutes', 'getMonth', 'getSeconds', 'getTime', 'getTimezoneOffset', 'getUTCDate', 'getUTCDay', 'getUTCFullYear', 'getUTCHours', 'getUTCMilliseconds', 'getUTCMinutes', 'getUTCMonth', 'getUTCSeconds', 'getYear', 'parse', 'parse', 'setDate', 'setDay', 'setFullYear', 'setHours', 'setMilliseconds', 'setMinutes', 'setMonth', 'setSeconds', 'setUTCDate', 'setUTCDay', 'setUTCFullYear', 'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes', 'setUTCMonth', 'setUTCSeconds', 'setYear', 'setTime', 'toGMTString', 'toLocaleString', 'toLocaleDateString', 'toLocaleTimeString', 'toSource', 'toString', 'toUTCString', 'UTC', 'valueOf', 'watch', 'unwatch']
    2              0.000083 		call map(datemeth, 'v:val."("')
    2              0.000003 		let dates = datemeth
                            
                            		" Function
    2              0.000008 		let funcprop = ['arguments', 'arguments.callee', 'arguments.caller', 'arguments.length', 'arity', 'constructor', 'length', 'prototype']
    2              0.000015 		let funcmeth = ['apply', 'call', 'toSource', 'toString', 'valueOf']
    2              0.000046 		call map(funcmeth, 'v:val."("')
    2              0.000008 		let funcs = funcprop + funcmeth
                            
                            		" Math
    2              0.000007 		let mathprop = ['E', 'LN2', 'LN10', 'LOG2E', 'LOG10E', 'PI', 'SQRT1_2', 'SQRT']
    2              0.000013 		let mathmeth = ['abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos', 'exp', 'floor', 'log', 'max', 'min', 'pow', 'random', 'round', 'sin', 'sqrt', 'tan', 'watch', 'unwatch']
    2              0.000050 		call map(mathmeth, 'v:val."("')
    2              0.000015 		let maths = mathprop + mathmeth
                            
                            		" Number
    2              0.000007 		let numbprop = ['MAX_VALUE', 'MIN_VALUE', 'NaN', 'NEGATIVE_INFINITY', 'POSITIVE_INFINITY',  'constructor', 'prototype']
    2              0.000006 		let numbmeth = ['toExponential', 'toFixed', 'toPrecision', 'toSource', 'toString', 'valueOf', 'watch', 'unwatch']
    2              0.000016 		call map(numbmeth, 'v:val."("')
    2              0.000007 		let numbs = numbprop + numbmeth
                            
                            		" Object
    2              0.000003 		let objeprop = ['constructor', 'prototype']
    2              0.000006 		let objemeth = ['eval', 'toSource', 'toString', 'unwatch', 'watch', 'valueOf']
    2              0.000012 		call map(objemeth, 'v:val."("')
    2              0.000006 		let objes = objeprop + objemeth
                            
                            		" RegExp
    2              0.000007 		let regeprop = ['constructor', 'global', 'ignoreCase', 'lastIndex', 'multiline', 'source', 'prototype']
    2              0.000016 		let regemeth = ['exec', 'test', 'toSource', 'toString', 'watch', 'unwatch']
    2              0.000013 		call map(regemeth, 'v:val."("')
    2              0.000005 		let reges = regeprop + regemeth
                            
                            		" String
    2              0.000004 		let striprop = ['constructor', 'length', 'prototype']
    2              0.000020 		let strimeth = ['anchor', 'big', 'blink', 'bold', 'charAt', 'charCodeAt', 'concat', 'fixed', 'fontcolor', 'fontsize', 'fromCharCode', 'indexOf', 'italics', 'lastIndexOf', 'link', 'match', 'replace', 'search', 'slice', 'small', 'split', 'strike', 'sub', 'substr', 'substring', 'sup', 'toLowerCase', 'toSource', 'toString', 'toUpperCase', 'watch', 'unwatch']
    2              0.000046 		call map(strimeth, 'v:val."("')
    2              0.000012 		let stris = striprop + strimeth
                            
                            		" User created properties
    2              0.000220 		let user_props1 = filter(copy(file), 'v:val =~ "this\\.\\k"')
    2              0.000005 		let juser_props1 = join(user_props1, ' ')
    2              0.000008 		let user_props1 = split(juser_props1, '\zethis\.')
    2              0.000002 		unlet! juser_props1
    2              0.000005 		call map(user_props1, 'matchstr(v:val, "this\\.\\zs\\k\\+\\ze")')
                            
    2              0.000209 		let user_props2 = filter(copy(file), 'v:val =~ "\\.prototype\\.\\k"')
    2              0.000004 		let juser_props2 = join(user_props2, ' ')
    2              0.000007 		let user_props2 = split(juser_props2, '\zeprototype\.')
    2              0.000002 		unlet! juser_props2
    2              0.000004 		call map(user_props2, 'matchstr(v:val, "prototype\\.\\zs\\k\\+\\ze")')
    2              0.000004 		let user_props = user_props1 + user_props2
                            
                            		" HTML DOM properties
                            		" Anchors - anchor.
    2              0.000009 		let anchprop = ['accessKey', 'charset', 'coords', 'href', 'hreflang', 'id', 'innerHTML', 'name', 'rel', 'rev', 'shape', 'tabIndex', 'target', 'type', 'onBlur', 'onFocus']
    2              0.000003 		let anchmeth = ['blur', 'focus']
    2              0.000007 		call map(anchmeth, 'v:val."("')
    2              0.000007 		let anths = anchprop + anchmeth
                            		" Area - area.
    2              0.000009 		let areaprop = ['accessKey', 'alt', 'coords', 'hash', 'host', 'hostname', 'href', 'id', 'noHref', 'pathname', 'port', 'protocol', 'search', 'shape', 'tabIndex', 'target']
    2              0.000005 		let areameth = ['onClick', 'onDblClick', 'onMouseOut', 'onMouseOver']
    2              0.000009 		call map(areameth, 'v:val."("')
    2              0.000008 		let areas = areaprop + areameth
                            		" Base - base.
    2              0.000003 		let baseprop = ['href', 'id', 'target']
    2              0.000002 		let bases = baseprop
                            		" Body - body.
    2              0.000009 		let bodyprop = ['aLink', 'background', 'gbColor', 'id', 'link', 'scrollLeft', 'scrollTop', 'text', 'vLink']
    2              0.000004 		let bodys = bodyprop
                            		" Document - document.
    2              0.000012 		let docuprop = ['anchors', 'applets', 'childNodes', 'embeds', 'forms', 'images', 'links', 'stylesheets', 'body', 'cookie', 'documentElement', 'domain', 'lastModified', 'referrer', 'title', 'URL']
    2              0.000016 		let documeth = ['close', 'createAttribute', 'createElement', 'createTextNode', 'focus', 'getElementById', 'getElementsByName', 'getElementsByTagName', 'open', 'write', 'writeln', 'onClick', 'onDblClick', 'onFocus', 'onKeyDown', 'onKeyPress', 'onKeyUp', 'onMouseDown', 'onMouseMove', 'onMouseOut', 'onMouseOver', 'onMouseUp', 'onResize']
    2              0.000034 		call map(documeth, 'v:val."("')
    2              0.000011 		let docuxprop = ['attributes', 'childNodes', 'doctype', 'documentElement', 'firstChild', 'implementation', 'namespaceURI', 'nextSibling', 'nodeName', 'nodeType', 'nodeValue', 'ownerDocument', 'parentNode', 'previousSibling']
    2              0.000010 		let docuxmeth = ['createAttribute', 'createCDATASection', 'createComment', 'createDocument', 'createDocumentFragment', 'createElement', 'createEntityReference', 'createProcessingInstruction', 'createTextNode']
    2              0.000016 		call map(docuxmeth, 'v:val."("')
    2              0.000062 		let docus = docuprop + docuxprop + documeth + docuxmeth
                            		" Form - form.
    2              0.000009 		let formprop = ['elements', 'acceptCharset', 'action', 'encoding', 'enctype', 'id', 'length', 'method', 'name', 'tabIndex', 'target']
    2              0.000005 		let formmeth = ['reset', 'submit', 'onReset', 'onSubmit']
    2              0.000009 		call map(formmeth, 'v:val."("')
    2              0.000007 		let forms = formprop + formmeth
                            		" Frame - frame.
    2              0.000007 		let framprop = ['contentDocument', 'frameBorder', 'id', 'longDesc', 'marginHeight', 'marginWidth', 'name', 'noResize', 'scrolling', 'src']
    2              0.000002 		let frammeth = ['blur', 'focus']
    2              0.000007 		call map(frammeth, 'v:val."("')
    2              0.000005 		let frams = framprop + frammeth
                            		" Frameset - frameset.
    2              0.000003 		let fsetprop = ['cols', 'id', 'rows']
    2              0.000003 		let fsetmeth = ['blur', 'focus']
    2              0.000007 		call map(fsetmeth, 'v:val."("')
    2              0.000004 		let fsets = fsetprop + fsetmeth
                            		" History - history.
    2              0.000003 		let histprop = ['length']
    2              0.000003 		let histmeth = ['back', 'forward', 'go']
    2              0.000008 		call map(histmeth, 'v:val."("')
    2              0.000004 		let hists = histprop + histmeth
                            		" Iframe - iframe.
    2              0.000008 		let ifraprop = ['align', 'frameBorder', 'height', 'id', 'longDesc', 'marginHeight', 'marginWidth', 'name', 'scrolling', 'src', 'width']
    2              0.000003 		let ifras = ifraprop
                            		" Image - image.
    2              0.000010 		let imagprop = ['align', 'alt', 'border', 'complete', 'height', 'hspace', 'id', 'isMap', 'longDesc', 'lowSrc', 'name', 'src', 'useMap', 'vspace', 'width']
    2              0.000003 		let imagmeth = ['onAbort', 'onError', 'onLoad']
    2              0.000007 		call map(imagmeth, 'v:val."("')
    2              0.000004 		let imags = histprop + imagmeth
                            		" Button - accessible only by other properties
    2              0.000006 		let buttprop = ['accessKey', 'disabled', 'form', 'id', 'name', 'tabIndex', 'type', 'value']
    2              0.000005 		let buttmeth = ['blur', 'click', 'focus', 'onBlur', 'onClick', 'onFocus', 'onMouseDown', 'onMouseUp']
    2              0.000015 		call map(buttmeth, 'v:val."("')
    2              0.000007 		let butts = buttprop + buttmeth
                            		" Checkbox - accessible only by other properties
    2              0.000008 		let checprop = ['accept', 'accessKey', 'align', 'alt', 'checked', 'defaultChecked',  'disabled', 'form', 'id', 'name', 'tabIndex', 'type', 'value'] 
    2              0.000007 		let checmeth = ['blur', 'click', 'focus', 'onBlur', 'onClick', 'onFocus', 'onMouseDown', 'onMouseUp']
    2              0.000014 		call map(checmeth, 'v:val."("')
    2              0.000008 		let checs = checprop + checmeth
                            		" File upload - accessible only by other properties
    2              0.000009 		let fileprop = ['accept', 'accessKey', 'align', 'alt', 'defaultValue',  'disabled', 'form', 'id', 'name', 'tabIndex', 'type', 'value'] 
    2              0.000006 		let filemeth = ['blur', 'focus', 'onBlur', 'onClick', 'onFocus', 'onMouseDown', 'onMouseUp']
    2              0.000014 		call map(filemeth, 'v:val."("')
    2              0.000007 		let files = fileprop + filemeth
                            		" Hidden - accessible only by other properties
    2              0.000005 		let hiddprop = ['defaultValue', 'form', 'id', 'name', 'type', 'value'] 
    2              0.000002 		let hidds = hiddprop
                            		" Password - accessible only by other properties
    2              0.000009 		let passprop = ['accept', 'accessKey', 'defaultValue',  'disabled', 'form', 'id', 'maxLength', 'name', 'readOnly', 'size', 'tabIndex',  'type', 'value'] 
    2              0.000008 		let passmeth = ['blur', 'click', 'focus', 'select', 'onBlur', 'onFocus', 'onKeyDown',  'onKeyPress', 'onKeyUp']
    2              0.000016 		call map(passmeth, 'v:val."("')
    2              0.000008 		let passs = passprop + passmeth
                            		" Radio - accessible only by other properties
    2              0.000008 		let radiprop = ['accept', 'accessKey', 'align', 'alt', 'checked', 'defaultChecked',  'disabled', 'form', 'id', 'name', 'tabIndex', 'type', 'value'] 
    2              0.000005 		let radimeth = ['blur', 'click', 'focus', 'select', 'onBlur', 'onFocus']
    2              0.000012 		call map(radimeth, 'v:val."("')
    2              0.000007 		let radis = radiprop + radimeth
                            		" Reset - accessible only by other properties
    2              0.000009 		let reseprop = ['accept', 'accessKey', 'align', 'alt', 'defaultValue',  'disabled', 'form', 'id', 'name', 'size', 'tabIndex', 'type', 'value'] 
    2              0.000006 		let resemeth = ['blur', 'click', 'focus', 'select', 'onBlur', 'onFocus']
    2              0.000012 		call map(resemeth, 'v:val."("')
    2              0.000007 		let reses = reseprop + resemeth
                            		" Submit - accessible only by other properties
    2              0.000009 		let submprop = ['accept', 'accessKey', 'align', 'alt', 'defaultValue',  'disabled', 'form', 'id', 'name', 'size', 'tabIndex', 'type', 'value'] 
    2              0.000006 		let submmeth = ['blur', 'click', 'focus', 'select', 'onClick', 'onSelectStart']
    2              0.000012 		call map(submmeth, 'v:val."("')
    2              0.000007 		let subms = submprop + submmeth
                            		" Text - accessible only by other properties
    2              0.000010 		let textprop = ['accept', 'accessKey', 'align', 'alt', 'defaultValue',  'disabled', 'form', 'id', 'maxLength', 'name', 'readOnly',  'size', 'tabIndex', 'type', 'value'] 
    2              0.000008 		let textmeth = ['blur', 'focus', 'select', 'onBlur', 'onChange', 'onFocus', 'onKeyDown', 'onKeyPress', 'onKeyUp', 'onSelect']
    2              0.000018 		call map(textmeth, 'v:val."("')
    2              0.000013 		let texts = textprop + textmeth
                            		" Link - link.
    2              0.000006 		let linkprop = ['charset', 'disabled', 'href', 'hreflang', 'id', 'media', 'rel', 'rev', 'target', 'type']
    2              0.000002 		let linkmeth = ['onLoad']
    2              0.000005 		call map(linkmeth, 'v:val."("')
    2              0.000005 		let links = linkprop + linkmeth
                            		" Location - location.
    2              0.000006 		let locaprop = ['href', 'hash', 'host', 'hostname', 'pathname', 'port', 'protocol', 'search']
    2              0.000003 		let locameth = ['assign', 'reload', 'replace']
    2              0.000009 		call map(locameth, 'v:val."("')
    2              0.000005 		let locas = locaprop + locameth
                            		" Meta - meta.
    2              0.000006 		let metaprop = ['charset', 'content', 'disabled', 'httpEquiv', 'name', 'scheme']
    2              0.000002 		let metas = metaprop
                            		" Navigator - navigator.
    2              0.000006 		let naviprop = ['plugins', 'appCodeName', 'appName', 'appVersion', 'cookieEnabled', 'platform', 'userAgent']
    2              0.000003 		let navimeth = ['javaEnabled', 'taintEnabled']
    2              0.000006 		call map(navimeth, 'v:val."("')
    2              0.000004 		let navis = naviprop + navimeth
                            		" Object - object.
    2              0.000013 		let objeprop = ['align', 'archive', 'border', 'code', 'codeBase', 'codeType', 'data', 'declare', 'form', 'height', 'hspace', 'id', 'name', 'standby', 'tabIndex', 'type', 'useMap', 'vspace', 'width']
    2              0.000004 		let objes = objeprop
                            		" Option - accessible only by other properties
    2              0.000007 		let optiprop = ['defaultSelected',  'disabled', 'form', 'id', 'index', 'label', 'selected', 'text', 'value']
    2              0.000002 		let optis = optiprop
                            		" Screen - screen.
    2              0.000005 		let screprop = ['availHeight', 'availWidth', 'colorDepth', 'height', 'width']
    2              0.000001 		let scres = screprop
                            		" Select - accessible only by other properties
    2              0.000009 		let seleprop = ['options', 'disabled', 'form', 'id', 'length', 'multiple', 'name',  'selectedIndex', 'size', 'tabIndex', 'type', 'value'] 
    2              0.000005 		let selemeth = ['blur', 'focus', 'remove', 'onBlur', 'onChange', 'onFocus']
    2              0.000024 		call map(selemeth, 'v:val."("')
    2              0.000007 		let seles = seleprop + selemeth
                            		" Style - style.
    2              0.000069 		let stylprop = ['background', 'backgroundAttachment', 'backgroundColor', 'backgroundImage', 'backgroundPosition', 'backgroundRepeat', 'border', 'borderBottom', 'borderLeft', 'borderRight', 'borderTop', 'borderBottomColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor', 'borderBottomStyle', 'borderLeftStyle', 'borderRightStyle', 'borderTopStyle', 'borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'borderColor', 'borderStyle', 'borderWidth', 'margin', 'marginBottom', 'marginLeft', 'marginRight', 'marginTop', 'outline', 'outlineStyle', 'outlineWidth', 'outlineColor', 'outlineStyle', 'outlineWidth', 'padding', 'paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop', 'clear', 'clip', 'clipBottom', 'clipLeft', 'clipRight', 'clipTop', 'content', 'counterIncrement', 'counterReset', 'cssFloat', 'cursor', 'direction', 'display', 'markerOffset', 'marks', 'maxHeight', 'maxWidth', 'minHeight', 'minWidth', 'overflow', 'overflowX', 'overflowY', 'verticalAlign', 'visibility', 'width', 'listStyle', 'listStyleImage', 'listStylePosition', 'listStyleType', 'cssText', 'bottom', 'height', 'left', 'position', 'right', 'top', 'width', 'zindex', 'orphans', 'widows', 'page', 'pageBreakAfter', 'pageBreakBefore', 'pageBreakInside', 'borderCollapse', 'borderSpacing', 'captionSide', 'emptyCells', 'tableLayout', 'color', 'font', 'fontFamily', 'fontSize', 'fontSizeAdjust', 'fontStretch', 'fontStyle', 'fontVariant', 'fontWeight', 'letterSpacing', 'lineHeight', 'quotes', 'textAlign', 'textIndent', 'textShadow', 'textTransform', 'textUnderlinePosition', 'unicodeBidi', 'whiteSpace', 'wordSpacing']
    2              0.000002 		let styls = stylprop
                            		" Table - table.
    2              0.000009 		let tablprop = ['rows', 'tBodies', 'align', 'bgColor', 'border', 'caption', 'cellPadding', 'cellSpacing', 'frame', 'height', 'rules', 'summary', 'tFoot', 'tHead', 'width']
    2              0.000006 		let tablmeth = ['createCaption', 'createTFoot', 'createTHead', 'deleteCaption', 'deleteRow', 'deleteTFoot', 'deleteTHead', 'insertRow']
    2              0.000015 		call map(tablmeth, 'v:val."("')
    2              0.000009 		let tabls = tablprop + tablmeth
                            		" Table data - TableData.
    2              0.000008 		let tdatprop = ['abbr', 'align', 'axis', 'bgColor', 'cellIndex', 'ch', 'chOff', 'colSpan', 'headers', 'noWrap', 'rowSpan', 'scope', 'vAlign', 'width']
    2              0.000002 		let tdats = tdatprop
                            		" Table row - TableRow.
    2              0.000005 		let trowprop = ['cells', 'align', 'bgColor', 'ch', 'chOff', 'rowIndex', 'sectionRowIndex', 'vAlign']
    2              0.000002 		let trowmeth = ['deleteCell', 'insertCell']
    2              0.000009 		call map(trowmeth, 'v:val."("')
    2              0.000005 		let trows = trowprop + trowmeth
                            		" Textarea - accessible only by other properties
    2              0.000009 		let tareprop = ['accessKey', 'cols', 'defaultValue',  'disabled', 'form', 'id', 'name', 'readOnly', 'rows',  'tabIndex', 'type', 'value', 'selectionStart', 'selectionEnd'] 
    2              0.000005 		let taremeth = ['blur', 'focus', 'select', 'onBlur', 'onChange', 'onFocus']
    2              0.000012 		call map(taremeth, 'v:val."("')
    2              0.000008 		let tares = tareprop + taremeth
                            		" Window - window.
    2              0.000011 		let windprop = ['frames', 'closed', 'defaultStatus', 'encodeURI', 'event', 'history', 'length', 'location', 'name', 'onload', 'opener', 'parent', 'screen', 'self', 'status', 'top', 'XMLHttpRequest', 'ActiveXObject']
    2              0.000011 		let windmeth = ['alert', 'blur', 'clearInterval', 'clearTimeout', 'close', 'confirm', 'focus', 'moveBy', 'moveTo', 'open', 'print', 'prompt', 'scrollBy', 'scrollTo', 'setInterval', 'setTimeout']
    2              0.000033 		call map(windmeth, 'v:val."("')
    2              0.000010 		let winds = windprop + windmeth
                            		" XMLHttpRequest - access by new xxx()
    2              0.000007 		let xmlhprop = ['onreadystatechange', 'readyState', 'responseText', 'responseXML', 'status', 'statusText', 'parseError']
    2              0.000006 		let xmlhmeth = ['abort', 'getAllResponseHeaders', 'getResponseHeaders', 'open', 'send', 'setRequestHeader']
    2              0.000015 		call map(xmlhmeth, 'v:val."("')
    2              0.000005 		let xmlhs = xmlhprop + xmlhmeth
                            
                            		" XML DOM
                            		" Attributes - element.attributes[x].
    2              0.000004 		let xdomattrprop = ['name', 'specified', 'value']
                            		" Element - anyelement.
    2              0.000010 		let xdomelemprop = ['attributes', 'childNodes', 'firstChild', 'lastChild',  'namespaceURI', 'nextSibling', 'nodeName', 'nodeType', 'nodeValue', 'ownerDocument', 'parentNode', 'prefix', 'previousSibling', 'tagName']
    2              0.000011 		let xdomelemmeth = ['appendChild', 'cloneNode', 'getAttribute', 'getAttributeNode', 'getElementsByTagName', 'hasChildNodes', 'insertBefore', 'normalize', 'removeAttribute', 'removeAttributeNode', 'removeChild', 'replaceChild', 'setAttribute', 'setAttributeNode']
    2              0.000023 		call map(xdomelemmeth, 'v:val."("')
    2              0.000010 		let xdomelems = xdomelemprop + xdomelemmeth
                            		" Node - anynode.
    2              0.000011 		let xdomnodeprop = ['attributes', 'childNodes', 'firstChild', 'lastChild',  'namespaceURI', 'nextSibling', 'nodeName', 'nodeType', 'nodeValue', 'ownerDocument', 'parentNode', 'prefix', 'previousSibling']
    2              0.000006 		let xdomnodemeth = ['appendChild', 'cloneNode', 'hasChildNodes', 'insertBefore', 'removeChild', 'replaceChild']
    2              0.000011 		call map(xdomnodemeth, 'v:val."("')
    2              0.000008 		let xdomnodes = xdomnodeprop + xdomnodemeth
                            		" NodeList 
    2              0.000003 		let xdomnliss = ['length', 'item(']
                            		" Error - parseError.
    2              0.000005 		let xdomerror = ['errorCode', 'reason', 'line', 'linepos', 'srcText', 'url', 'filepos']
                            
                            		" Find object type declaration to reduce number of suggestions. {{{
                            		" 1. Get object name
                            		" 2. Find object declaration line
                            		" 3. General declaration follows "= new Type" syntax, additional else
                            		"    for regexp "= /re/"
                            		" 4. Make correction for Microsoft.XMLHTTP ActiveXObject
                            		" 5. Repeat for external files
    2              0.000024 		let object = matchstr(shortcontext, '\zs\k\+\ze\(\[.\{-}\]\)\?\.$')
    2              0.000005 		if len(object) > 0
    2              0.000072 			let decl_line = search(object.'.\{-}=\s*new\s*', 'bn')
    2              0.000002 			if decl_line > 0
                            				let object_type = matchstr(getline(decl_line), object.'.\{-}=\s*new\s*\zs\k\+\ze')
                            				if object_type == 'ActiveXObject' && matchstr(getline(decl_line), object.'.\{-}=\s*new\s*ActiveXObject\s*(.Microsoft\.XMLHTTP.)') != ''
                            						let object_type = 'XMLHttpRequest'
                            				endif
                            			else
    2              0.000033 				let decl_line = search('var\s*'.object.'\s*=\s*\/', 'bn')
    2              0.000002 				if decl_line > 0
                            					let object_type = 'RegExp'
                            				endif
    2              0.000002 			endif
                            			" We didn't find var declaration in current file but we may have
                            			" something in external files.
    2              0.000005 			if decl_line == 0 && exists("b:js_extfiles")
                            				let dext_line = filter(copy(b:js_extfiles), 'v:val =~ "'.object.'.\\{-}=\\s*new\\s*"')
                            				if len(dext_line) > 0
                            					let object_type = matchstr(dext_line[-1], object.'.\{-}=\s*new\s*\zs\k\+\ze')
                            					if object_type == 'ActiveXObject' && matchstr(dext_line[-1], object.'.\{-}=\s*new\s*ActiveXObject\s*(.Microsoft\.XMLHTTP.)') != ''
                            							let object_type = 'XMLHttpRequest'
                            					endif
                            				else
                            					let dext_line = filter(copy(b:js_extfiles), 'v:val =~ "var\s*'.object.'\\s*=\\s*\\/"')
                            					if len(dext_line) > 0
                            						let object_type = 'RegExp'
                            					endif
                            				endif
                            			endif
    2              0.000001 		endif
                            		" }}}
                            
    2              0.000004 		if !exists('object_type')
    2              0.000002 			let object_type = ''
    2              0.000002 		endif
                            
    2              0.000003 		if object_type == 'Date'
                            			let values = dates
                            		elseif object_type == 'Image'
                            			let values = imags
                            		elseif object_type == 'Array'
                            			let values = arrays
                            		elseif object_type == 'Boolean'
                            			" TODO: a bit more than real boolean
                            			let values = arrays
                            		elseif object_type == 'XMLHttpRequest'
                            			let values = xmlhs
                            		elseif object_type == 'String'
                            			let values = stris
                            		elseif object_type == 'RegExp'
                            			let values = reges
                            		elseif object_type == 'Math'
                            			let values = maths
                            		endif
                            
    2              0.000002 		if !exists('values')
                            		" List of properties
    2              0.000007 		if shortcontext =~ 'Math\.$'
                            			let values = maths
                            		elseif shortcontext =~ 'anchors\(\[.\{-}\]\)\?\.$'
                            			let values = anths
                            		elseif shortcontext =~ 'area\.$'
                            			let values = areas
                            		elseif shortcontext =~ 'base\.$'
                            			let values = bases
                            		elseif shortcontext =~ 'body\.$'
                            			let values = bodys
                            		elseif shortcontext =~ 'document\.$'
                            			let values = docus
                            		elseif shortcontext =~ 'forms\(\[.\{-}\]\)\?\.$'
                            			let values = forms
                            		elseif shortcontext =~ 'frameset\.$'
                            			let values = fsets
                            		elseif shortcontext =~ 'history\.$'
                            			let values = hists
                            		elseif shortcontext =~ 'iframe\.$'
                            			let values = ifras
                            		elseif shortcontext =~ 'images\(\[.\{-}\]\)\?\.$'
                            			let values = imags
                            		elseif shortcontext =~ 'links\(\[.\{-}\]\)\?\.$'
                            			let values = links
                            		elseif shortcontext =~ 'location\.$'
                            			let values = locas
                            		elseif shortcontext =~ 'meta\.$'
                            			let values = metas
                            		elseif shortcontext =~ 'navigator\.$'
                            			let values = navis
                            		elseif shortcontext =~ 'object\.$'
                            			let values = objes
                            		elseif shortcontext =~ 'screen\.$'
                            			let values = scres
                            		elseif shortcontext =~ 'style\.$'
                            			let values = styls
                            		elseif shortcontext =~ 'table\.$'
                            			let values = tabls
                            		elseif shortcontext =~ 'TableData\.$'
                            			let values = tdats
                            		elseif shortcontext =~ 'TableRow\.$'
                            			let values = trows
                            		elseif shortcontext =~ 'window\.$'
                            			let values = winds
                            		elseif shortcontext =~ 'parseError\.$'
                            			let values = xdomerror
                            		elseif shortcontext =~ 'attributes\[\d\+\]\.$'
                            			let values = xdomattrprop
                            		else
    2              0.000389 			let values = user_props + arrays + dates + funcs + maths + numbs + objes + reges + stris
    2              0.000413 			let values += doms + anths + areas + bases + bodys + docus + forms + frams + fsets + hists
    2              0.000190 			let values += ifras + imags + links + locas + metas + navis + objes + scres
    2              0.000142 			let values += tabls + trows + tares + winds
    2              0.000051 			let values += xdomnodes + xdomnliss + xdomelems
    2              0.000001 		endif
    2              0.000001 		endif
                            
 1108              0.000709 		for m in values
 1106              0.002305 			if m =~? '^'.a:base
 1106              0.001487 				call add(res, m)
 1106              0.000660 			elseif m =~? a:base
                            				call add(res2, m)
                            			endif
 1106              0.000431 		endfor
                            
    2              0.000138 		unlet! values
    2              0.000156 		return res + res2
                            
                            	endif
                            	" }}}
                            
                            	" Get variables data.
                            	let variables = filter(copy(file), 'v:val =~ "var\\s"')
                            	call map(variables, 'matchstr(v:val, ".\\{-}var\\s\\+\\zs.*\\ze")')
                            	call map(variables, 'substitute(v:val, ";\\|$", ",", "g")')
                            	let vars = []
                            	" This loop (and next one) is necessary to get variable names from
                            	" constructs like: var var1, var2, var3 = "something";
                            	for i in range(len(variables))
                            		let comma_separated = split(variables[i], ',\s*')
                            		call map(comma_separated, 'matchstr(v:val, "\\k\\+")')
                            		let vars += comma_separated
                            	endfor
                            
                            	let variables = sort(vars)
                            	unlet! vars
                            
                            	" Add "no var" variables.
                            	let undeclared_variables = filter(copy(file), 'v:val =~ "^\\s*\\k\\+\\s*="')
                            	let u_vars = []
                            	for i in range(len(undeclared_variables))
                            		let  split_equal = split(undeclared_variables[i], '\s*=')
                            		call map(split_equal, 'matchstr(v:val, "\\k\\+$")')
                            		let u_vars += split_equal
                            	endfor
                            
                            	let variables += sort(u_vars)
                            	unlet! u_vars
                            
                            	" Get functions
                            	let functions = filter(copy(file), 'v:val =~ "^\\s*function\\s"')
                            	let arguments = copy(functions)
                            	call map(functions, 'matchstr(v:val, "^\\s*function\\s\\+\\zs\\k\\+")')
                            	call map(functions, 'v:val."("')
                            	let functions = sort(functions)
                            
                            	" Create table to keep arguments for additional 'menu' info
                            	let b:js_menuinfo = {}
                            	for i in arguments
                            		let g:ia = i
                            		let f_elements = matchlist(i, 'function\s\+\(\k\+\)\s*(\(.\{-}\))')
                            		if len(f_elements) == 3
                            			let b:js_menuinfo[f_elements[1].'('] = f_elements[2]
                            		endif
                            	endfor
                            
                            	" Get functions arguments
                            	call map(arguments, 'matchstr(v:val, "function.\\{-}(\\zs.\\{-}\\ze)")')
                            	let jargs = join(arguments, ',')
                            	let jargs = substitute(jargs, '\s', '', 'g')
                            	let arguments = split(jargs, ',')
                            	let arguments = sort(arguments)
                            
                            	" Built-in functions
                            	let builtin = ['alert(', 'confirm(']
                            
                            	" Top-level HTML DOM objects
                            	let htmldom = ['document', 'anchor', 'area', 'base', 'body', 'document', 'event', 'form', 'frame', 'frameset', 'history', 'iframe', 'image', 'input', 'link', 'location', 'meta', 'navigator', 'object', 'option', 'screen', 'select', 'table', 'tableData', 'tableHeader', 'tableRow', 'textarea', 'window']
                            	call map(htmldom, 'v:val."."')
                            
                            	" Top-level properties
                            	let properties = ['decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'eval', 'Infinity', 'isFinite', 'isNaN', 'NaN', 'Number', 'parseFloat', 'parseInt', 'String', 'undefined', 'escape', 'unescape']
                            
                            	" Keywords
                            	let keywords = ["Array", "Boolean", "Date", "Function", "Math", "Number", "Object", "RegExp", "String", "XMLHttpRequest", "ActiveXObject", "abstract", "boolean", "break", "byte", "case", "catch", "char", "class", "const", "continue", "debugger", "default", "delete", "do", "double ", "else", "enum", "export", "extends", "false", "final", "finally", "float", "for", "function", "goto", "if", "implements", "import", "in ", "instanceof", "int", "interface", "long", "native", "new", "null", "package", "private", "protected", "public", "return", "short", "static", "super ", "switch", "synchronized", "this", "throw", "throws", "transient", "true", "try", "typeof", "var", "void", "volatile", "while", "with"]
                            
                            	let values = variables + functions + htmldom + arguments + builtin + properties + keywords
                            
                            	for m in values
                            		if m =~? '^'.a:base
                            			call add(res, m)
                            		elseif m =~? a:base
                            			call add(res2, m)
                            		endif
                            	endfor
                            
                            	let menu = res + res2
                            	let final_menu = []
                            	for i in range(len(menu))
                            		let item = menu[i]
                            		if item =~ '($'
                            			let kind = 'f'
                            			if has_key(b:js_menuinfo, item)
                            				let m_info = b:js_menuinfo[item]
                            			else
                            				let m_info = ''
                            			endif
                            		else
                            			let kind = 'v'
                            			let m_info = ''
                            		endif
                            		let final_menu += [{'word':item, 'menu':m_info, 'kind':kind}]
                            	endfor
                            	let g:fm = final_menu
                            	return final_menu
                            

FUNCTION  gitgutter#all()
Called 1 time
Total time:   0.027440
 Self time:   0.000275

count  total (s)   self (s)
    3              0.000014   for buffer_id in tabpagebuflist()
    2              0.000116     let file = expand('#' . buffer_id . ':p')
    2              0.000037     if !empty(file)
    2   0.027234   0.000069       call gitgutter#process_buffer(buffer_id, 0)
    2              0.000004     endif
    2              0.000004   endfor

FUNCTION  gitgutter#utility#extension()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004   return fnamemodify(s:file, ':e')

FUNCTION  neocomplete#variables#get_source()
Called 40 times
Total time:   0.000276
 Self time:   0.000276

count  total (s)   self (s)
   40              0.000090   if !exists('s:sources')
                                let s:sources = {}
                              endif
   40              0.000104   return get(s:sources, a:name, {})

FUNCTION  <SNR>167_escape_pattern()
Called 9 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    9              0.000022   return escape(a:str, '~"\.^$[]*')

FUNCTION  SyntaxCheckers_javascript_jshint_GetLocList()
Called 1 time
Total time:   0.224048
 Self time:   0.000063

count  total (s)   self (s)
    1   0.000040   0.000012     call syntastic#log#deprecationWarn('javascript_jshint_conf', 'javascript_jshint_args', "'--config ' . syntastic#util#shexpand(OLD_VAR)")
                            
    1   0.000432   0.000010     let makeprg = self.makeprgBuild({ 'args_after': (s:jshint_new ? '--verbose ' : '') })
                            
    1              0.000004     let errorformat = s:jshint_new ? '%A%f: line %l\, col %v\, %m \(%t%*\d\)' : '%E%f: line %l\, col %v\, %m'
                            
    1   0.223569   0.000034     return SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat, 'defaults': {'bufnr': bufnr('')}, 'returns': [0, 2] })

FUNCTION  unite#util#substitute_path_separator()
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000002     return a:path

FUNCTION  airline#highlighter#highlight()
Called 12 times
Total time:   0.936765
 Self time:   0.191731

count  total (s)   self (s)
   12              0.000037   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   12              0.000097   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   12              0.000028   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   32              0.000045   for mode in mapped
   20              0.000102     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   20              0.000056       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
 1902              0.003747       for kvp in items(dict)
 1882              0.003491         let mode_colors = kvp[1]
 1882   0.075890   0.008442         call airline#highlighter#exec(kvp[0].suffix, mode_colors)
                            
 5646              0.009449         for accent in keys(s:accents)
 3764              0.007110           if !has_key(p.accents, accent)
                                        continue
                                      endif
 3764              0.011759           let colors = copy(mode_colors)
 3764              0.008204           if p.accents[accent][0] != ''
 1882              0.004486             let colors[0] = p.accents[accent][0]
 1882              0.001151           endif
 3764              0.006499           if p.accents[accent][2] != ''
 1882              0.004019             let colors[2] = p.accents[accent][2]
 1882              0.000950           endif
 3764              0.004727           if len(colors) >= 5
  160              0.000422             let colors[4] = get(p.accents[accent], 4, '')
  160              0.000099           else
 3604              0.010942             call add(colors, get(p.accents[accent], 4, ''))
 3604              0.001927           endif
 3764   0.159488   0.018979           call airline#highlighter#exec(kvp[0].suffix.'_'.accent, colors)
 3764              0.003353         endfor
 1882              0.000992       endfor
                            
                                  " TODO: optimize this
 1900              0.004244       for sep in items(s:separators)
 1880   0.554749   0.017672         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
 1880              0.001836       endfor
   20              0.000010     endif
   20              0.000014   endfor

FUNCTION  <SNR>185_is_skip_auto_complete()
Called 12 times
Total time:   0.000383
 Self time:   0.000298

count  total (s)   self (s)
   12   0.000135   0.000050   let neocomplete = neocomplete#get_current_neocomplete()
                            
   12              0.000116   if (g:neocomplete#lock_iminsert && &l:iminsert) || (&l:formatoptions =~# '[tca]' && &l:textwidth > 0     && strwidth(a:cur_text) >= &l:textwidth)
                                let neocomplete.skip_next_complete = 0
                                return 1
                              endif
                            
   12              0.000023   let skip = neocomplete.skip_next_complete
                            
   12              0.000027   if !skip || a:cur_text !=# neocomplete.old_cur_text
   11              0.000006     return 0
                              endif
                            
    1              0.000001   let neocomplete.skip_next_complete = 0
    1              0.000001   return skip

FUNCTION  <SNR>171_make_cache_current_buffer()
Called 6 times
Total time:   0.014776
 Self time:   0.008081

count  total (s)   self (s)
    6              0.000016   let srcname = bufnr('%')
                            
                              " Make cache from current buffer.
    6   0.000370   0.000034   if !s:should_create_cache(srcname)
                                return
                              endif
                            
    6   0.000216   0.000030   if !s:exists_current_source()
                                call s:initialize_source(srcname)
                              endif
                            
    6              0.000017   let source = s:buffer_sources[srcname]
    6              0.000013   let keyword_pattern = source.keyword_pattern
    6              0.000007   if keyword_pattern == ''
                                return
                              endif
                            
    6              0.000007   let words = []
                            
    6              0.000007   lua << EOF
                            do
                              local words = vim.eval('words')
                              local dup = {}
                              local b = vim.buffer()
                              local min_length = vim.eval('g:neocomplete#min_keyword_length')
                              for linenr = vim.eval('a:start'), vim.eval('a:end') do
                                local match = 0
                                while 1 do
                                  local match_str = vim.eval('matchstr(getline('..linenr..
                                  '), keyword_pattern, ' .. match .. ')')
                                  if match_str == '' then
                                    break
                                  end
                                  if dup[match_str] == nil
                                    and string.len(match_str) >= min_length then
                                    dup[match_str] = 1
                                    words:add(match_str)
                                  end
                            
                                  -- Next match.
                                  match = vim.eval('matchend(getline(' .. linenr ..
                                    '), keyword_pattern, ' .. match .. ')')
                                end
                              end
                            end
                            EOF
                            
    6   0.006455   0.000282   let source.words = neocomplete#util#uniq(source.words + words)

FUNCTION  NERDTreeGitStatusRefreshListener()
Called 72 times
Total time:   0.077386
 Self time:   0.001426

count  total (s)   self (s)
   72              0.000180     if !exists('b:NOT_A_GIT_REPOSITORY')
                                    call g:NERDTreeGitStatusRefresh()
                                endif
   72              0.000101     let l:path = a:event.subject
   72   0.075433   0.000314     let l:flag = g:NERDTreeGetGitStatusPrefix(l:path)
   72   0.000787   0.000312     call l:path.flagSet.clearFlags('git')
   72              0.000095     if l:flag !=# ''
   20   0.000447   0.000081         call l:path.flagSet.addFlag('git', l:flag)
   20              0.000011     endif

FUNCTION  unite#handlers#_on_cursor_hold()
Called 1 time
Total time:   0.000105
 Self time:   0.000056

count  total (s)   self (s)
    1              0.000002   let is_async = 0
                            
    1   0.000014   0.000008   call s:restore_statusline()
                            
    1              0.000001   if &filetype ==# 'unite'
                                " Redraw.
                                call unite#redraw()
                            
                                let unite = unite#get_current_unite()
                                let is_async = unite.is_async
                            
                                if !unite.is_async && unite.context.auto_quit
                                  call unite#force_quit_session()
                                endif
                              else
                                " Search other unite window.
    1              0.000013     for winnr in filter(range(1, winnr('$')), "getbufvar(winbufnr(v:val), '&filetype') ==# 'unite'")
                                  let unite = getbufvar(winbufnr(winnr), 'unite')
                                  if unite.is_async
                                    " Redraw unite buffer.
                                    call unite#redraw(winnr)
                            
                                    let is_async = unite.is_async
                                  endif
                                endfor
                            
    1   0.000049   0.000006     call unite#handlers#_restore_updatetime()
    1              0.000001   endif
                            
    1              0.000001   if is_async
                                " Ignore key sequences.
                                call feedkeys("g\<ESC>" . (v:count > 0 ? v:count : ''), 'n')
                              endif

FUNCTION  vimproc#pgroup_open()
Called 1 time
Total time:   0.006569
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000004   if type(a:statements) == type('')
                                let statements = vimproc#parser#parse_statements(a:statements)
                                for statement in statements
                                  let statement.statement = vimproc#parser#parse_pipe(statement.statement)
                                endfor
                              else
    1              0.000003     let statements = a:statements
    1              0.000000   endif
                            
    1              0.000002   let is_pty = get(a:000, 0, 0)
    1              0.000002   let npipe = get(a:000, 1, 3)
                            
    1   0.006545   0.000017   return s:pgroup_open(statements, is_pty && !vimproc#util#is_windows(), npipe)

FUNCTION  <SNR>145_closed_fdopen()
Called 1 time
Total time:   0.000179
 Self time:   0.000039

count  total (s)   self (s)
    1   0.000175   0.000035   return { 'fd' : -1, 'eof' : 1, '__eof' : 1, 'is_valid' : 0, 'buffer' : [], 'f_close' : s:funcref(a:f_close), 'f_read' : s:funcref(a:f_read), 'f_write' : s:funcref(a:f_write), 'close' : s:funcref('close'), 'read' : s:funcref('read'), 'write' : s:funcref('write'), 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),}

FUNCTION  gitgutter#sign#upsert_new_gitgutter_signs()
Called 3 times
Total time:   0.000755
 Self time:   0.000720

count  total (s)   self (s)
    3   0.000024   0.000018   let bufnr = gitgutter#utility#bufnr()
    3              0.000020   let other_signs         = getbufvar(bufnr, 'gitgutter_other_signs')
    3              0.000012   let old_gitgutter_signs = getbufvar(bufnr, 'gitgutter_gitgutter_signs')
                            
    5              0.000011   for line in a:modified_lines
    2              0.000008     let line_number = line[0]  " <number>
    2              0.000006     if index(other_signs, line_number) == -1  " don't clobber others' signs
    2   0.000044   0.000027       let name = gitgutter#utility#highlight_name_for_change(line[1])
    2              0.000006       if !has_key(old_gitgutter_signs, line_number)  " insert
    2   0.000024   0.000012         let id = gitgutter#sign#next_sign_id()
    2              0.000473         execute "sign place" id "line=" . line_number "name=" . name "buffer=" . bufnr
    2              0.000005       else  " update if sign has changed
                                    let old_sign = old_gitgutter_signs[line_number]
                                    if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . bufnr
                                    end
                                  endif
    2              0.000001     endif
    2              0.000003   endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  <SNR>185_complete_key()
Called 6 times
Total time:   0.000374
 Self time:   0.000061

count  total (s)   self (s)
    6   0.000346   0.000033   call neocomplete#helper#complete_configure()
                            
    6              0.000022   call feedkeys(a:key)

FUNCTION  gitgutter#diff#parse_hunk()
Called 1 time
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    1              0.000043   let matches = matchlist(a:line, s:hunk_re)
    1              0.000002   if len(matches) > 0
    1              0.000004     let from_line  = str2nr(matches[1])
    1              0.000004     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
    1              0.000002     let to_line    = str2nr(matches[3])
    1              0.000003     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
    1              0.000005     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  gitgutter#utility#has_fresh_changes()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return getbufvar(s:bufnr, 'changedtick') != getbufvar(s:bufnr, 'gitgutter_last_tick')

FUNCTION  <SNR>185_make_cache_current_line()
Called 2 times
Total time:   0.006744
 Self time:   0.000051

count  total (s)   self (s)
    2   0.000020   0.000007   let neocomplete = neocomplete#get_current_neocomplete()
    2   0.000119   0.000011   if neocomplete#helper#is_enabled_source('buffer', neocomplete.context_filetype)
                                " Caching current cache line.
    2   0.005509   0.000008     call neocomplete#sources#buffer#make_cache_current_line()
    2              0.000002   endif
    2   0.000101   0.000010   if neocomplete#helper#is_enabled_source('member', neocomplete.context_filetype)
                                " Caching current cache line.
    2   0.000988   0.000008     call neocomplete#sources#member#make_cache_current_line()
    2              0.000002   endif

FUNCTION  neocomplete#handler#_on_text_changed()
Called 10 times
Total time:   0.000551
 Self time:   0.000181

count  total (s)   self (s)
   10   0.000333   0.000036   if neocomplete#is_cache_disabled()
                                return
                              endif
                            
   10              0.000020   if getline('.') == ''
                                call s:make_cache_current_line()
                              endif
                            
   10   0.000107   0.000034   if !neocomplete#util#is_text_changed()
                                call s:indent_current_line()
                              endif

FUNCTION  airline#parts#paste()
Called 70 times
Total time:   0.000381
 Self time:   0.000381

count  total (s)   self (s)
   70              0.000350   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  neocomplete#complete#_set_previous_position()
Called 18 times
Total time:   0.000322
 Self time:   0.000217

count  total (s)   self (s)
   18   0.000162   0.000057   let neocomplete = neocomplete#get_current_neocomplete()
   18              0.000039   let neocomplete.old_complete_pos = a:complete_pos
   18              0.000043   let neocomplete.old_linenr = line('.')
   18              0.000062   let neocomplete.old_cur_text = a:cur_text

FUNCTION  unite#sources#rec#_append()
Called 1 time
Total time:   0.000120
 Self time:   0.000117

count  total (s)   self (s)
    1              0.000026   let path = expand('%:p')
    1              0.000011   if path !~ '\a\+:'
    1              0.000015     let path = simplify(resolve(path))
    1              0.000001   endif
                            
                              " Append the current buffer to the mru list.
    1              0.000020   if !filereadable(path) || &l:buftype =~# 'help\|nofile'
                                return
                              endif
                            
    1   0.000012   0.000010   let path = unite#util#substitute_path_separator(path)
                            
                              " Check continuation.
    1   0.000007   0.000006   let base_path = unite#util#substitute_path_separator( fnamemodify(path, ':h')) . '/'
    1              0.000015   for continuation in values(filter(copy(s:continuation.file), "stridx(v:key.'/', base_path) == 0"))
                                let continuation.files = unite#util#uniq(add( continuation.files, { 'word' : path, 'action__path' : path, }))
                              endfor

FUNCTION  neocomplete#complete#_get_complete_pos()
Called 12 times
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
   12              0.000020   if empty(a:sources)
                                return -1
                              endif
                            
   12              0.000105   return min([col('.')] + map(copy(a:sources), 'v:val.neocomplete__context.complete_pos'))

FUNCTION  neocomplete#cache#writefile()
Called 1 time
Total time:   0.001009
 Self time:   0.000030

count  total (s)   self (s)
    1   0.000008   0.000004   if neocomplete#util#is_sudo()
                                return
                              endif
                            
    1   0.000049   0.000004   let cache_dir = neocomplete#get_data_directory() . '/' . a:cache_dir
    1   0.000951   0.000021   return s:Cache.writefile(cache_dir, a:filename, a:list)

FUNCTION  neocomplete#init#is_enabled()
Called 76 times
Total time:   0.000194
 Self time:   0.000194

count  total (s)   self (s)
   76              0.000136   return s:is_enabled

FUNCTION  vimproc#plineopen3()
Called 1 time
Total time:   0.005841
 Self time:   0.000071

count  total (s)   self (s)
    1              0.000004   let commands = type(a:commands) == type('') ? vimproc#parser#parse_pipe(a:commands) : a:commands
    1              0.000003   let is_pty = get(a:000, 0, 0)
                            
    1   0.005830   0.000060   return s:plineopen(3, commands, is_pty)

FUNCTION  gitgutter#sign#obsolete_gitgutter_signs_to_remove()
Called 3 times
Total time:   0.000149
 Self time:   0.000141

count  total (s)   self (s)
    3   0.000036   0.000028   let bufnr = gitgutter#utility#bufnr()
    3              0.000007   let signs_to_remove = []  " list of [<id (number)>, ...]
    3              0.000007   let remove_all_signs = 1
    3              0.000014   let old_gitgutter_signs = getbufvar(bufnr, 'gitgutter_gitgutter_signs')
    3              0.000014   for line_number in keys(old_gitgutter_signs)
                                if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
                                  let remove_all_signs = 0
                                endif
                              endfor
    3              0.000007   let s:remove_all_old_signs = remove_all_signs
    3              0.000005   return signs_to_remove

FUNCTION  <SNR>56_FileUpdate()
Called 1 time
Total time:   0.063683
 Self time:   0.000313

count  total (s)   self (s)
    1              0.000002     if g:NERDTreeUpdateOnWrite != 1
                                    return
                                endif
    1   0.000474   0.000018     if !g:NERDTree.IsOpen()
                                    return
                                endif
                            
    1              0.000003     let l:winnr = winnr()
                            
    1   0.000930   0.000009     call g:NERDTree.CursorToTreeWin()
    1   0.006231   0.000048     let l:node = b:NERDTreeRoot.findNode(g:NERDTreePath.New(a:fname))
    1              0.000001     if l:node == {}
                                    return
                                endif
    1   0.029394   0.000016     call l:node.refreshFlags()
    1              0.000005     let l:node = l:node.parent
    4              0.000008     while !empty(l:node)
    3   0.001458   0.000017         call l:node.refreshDirFlags()
    3              0.000008         let l:node = l:node.parent
    3              0.000003     endwhile
                            
    1   0.024996   0.000005     call NERDTreeRender()
    1              0.000147     exec l:winnr . 'wincmd w'

FUNCTION  neomru#_append()
Called 1 time
Total time:   0.000547
 Self time:   0.000297

count  total (s)   self (s)
    1              0.000013   if &l:buftype =~ 'help\|nofile' || &l:previewwindow
                                return
                              endif
                            
    1   0.000097   0.000078   let path = s:substitute_path_separator(expand('%:p'))
    1              0.000043   if path !~ '\a\+:'
    1   0.000055   0.000043     let path = s:substitute_path_separator( simplify(s:resolve(path)))
    1              0.000002   endif
                            
                              " Append the current buffer to the mru list.
    1   0.000077   0.000011   if s:is_file_exist(path)
    1   0.000058   0.000011     call s:file_mru.append(path)
    1              0.000001   endif
                            
    1              0.000005   let filetype = getbufvar(bufnr('%'), '&filetype')
    1              0.000004   if filetype ==# 'vimfiler' && type(getbufvar(bufnr('%'), 'vimfiler')) == type({})
                                let path = getbufvar(bufnr('%'), 'vimfiler').current_dir
                              elseif filetype ==# 'vimshell' && type(getbufvar(bufnr('%'), 'vimshell')) == type({})
                                let path = getbufvar(bufnr('%'), 'vimshell').current_dir
                              else
    1              0.000017     let path = getcwd()
    1              0.000001   endif
                            
    1   0.000046   0.000019   let path = s:substitute_path_separator(simplify(s:resolve(path)))
                              " Chomp last /.
    1              0.000010   let path = substitute(path, '/$', '', '')
                            
                              " Append the current buffer to the mru list.
    1   0.000064   0.000011   if s:is_directory_exist(path)
    1   0.000036   0.000010     call s:directory_mru.append(path)
    1              0.000001   endif

FUNCTION  <SNR>157_substitute_path_separator()
Called 3 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    3              0.000023   return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTION  <SNR>182_set_complete_results_words()
Called 2 times
Total time:   0.019744
 Self time:   0.000733

count  total (s)   self (s)
                              " Try source completion.
    4              0.000019   for [omnifunc, result] in items(a:complete_results)
    2   0.000152   0.000004     if neocomplete#complete_check()
                                  return a:complete_results
                                endif
                            
    2              0.000004     let pos = getpos('.')
                            
    2              0.000002     try
    2   0.012295   0.000600       let ret = call(omnifunc, [0, result.complete_str])
    2              0.000008       let list = type(ret) == type([]) ? ret : ret.words
    2              0.000002     catch
                                  call neocomplete#print_error( 'Error occurred calling omnifunction: ' . omnifunc)
                                  call neocomplete#print_error(v:throwpoint)
                                  call neocomplete#print_error(v:exception)
                                  let list = []
                                finally
    2              0.000004       call setpos('.', pos)
    2              0.000002     endtry
                            
    2   0.007183   0.000015     let list = s:get_omni_list(list)
                            
    2              0.000005     let result.candidates = list
    2              0.000001   endfor
                            
    2              0.000003   return a:complete_results

FUNCTION  airline#parts#readonly()
Called 107 times
Total time:   0.000296
 Self time:   0.000296

count  total (s)   self (s)
  107              0.000222   return &readonly ? g:airline_symbols.readonly : ''

FUNCTION  neocomplete#is_multibyte_input()
Called 10 times
Total time:   0.000302
 Self time:   0.000302

count  total (s)   self (s)
   10              0.000294   return (exists('b:skk_on') && b:skk_on)   || (!g:neocomplete#enable_multibyte_completion         && char2nr(split(a:cur_text, '\zs')[-1]) > 0x80)

FUNCTION  <SNR>145_vp_pipes_close()
Called 3 times
Total time:   0.000420
 Self time:   0.000047

count  total (s)   self (s)
    6              0.000011   for fd in self.fd
    3              0.000003     try
    3   0.000380   0.000007       call fd.close()
    3              0.000003     catch /vimproc: vp_pipe_close: /
                                  " Ignore error.
                                endtry
    3              0.000002   endfor

FUNCTION  <SNR>145_convert_args()
Called 1 time
Total time:   0.000653
 Self time:   0.000165

count  total (s)   self (s)
    1              0.000001   if empty(a:args)
                                return []
                              endif
                            
    1   0.000365   0.000100   let args = map(copy(a:args), 'vimproc#util#iconv( v:val, &encoding, vimproc#util#systemencoding())')
                            
    1   0.000004   0.000003   if vimproc#util#is_windows() && !executable(a:args[0])
                                " Search from internal commands.
                                let internal_commands = [ 'copy', 'date', 'del', 'dir', 'echo', 'erase', 'for', 'ftype', 'if', 'md', 'mkdir', 'move', 'path', 'rd', 'ren', 'rename', 'rmdir', 'start', 'time', 'type', 'ver', 'vol']
                                let index = index(internal_commands, a:args[0], 0, 1)
                                if index >= 0
                                  " Use cmd.exe
                                  return ['cmd', '/c', args[0]] + args[1:]
                                endif
                              endif
                            
    1   0.000106   0.000009   let command_name = vimproc#get_command_name(a:args[0])
                            
    1   0.000165   0.000040   return map(vimproc#analyze_shebang(command_name), 'vimproc#util#iconv( v:val, &encoding, vimproc#util#systemencoding())') + args[1:]

FUNCTION  vimproc#util#cd()
Called 2 times
Total time:   0.000231
 Self time:   0.000231

count  total (s)   self (s)
    2              0.000230   execute (haslocaldir() ? 'lcd' : 'cd') fnameescape(a:path)

FUNCTION  neocomplete#filters#escape()
Called 22 times
Total time:   0.000213
 Self time:   0.000213

count  total (s)   self (s)
                              " Escape string for lua regexp.
   22              0.000182   return substitute(a:string, '[%\[\]().*+?^$-]', '%\0', 'g')

FUNCTION  neocomplete#complete_check()
Called 34 times
Total time:   0.001714
 Self time:   0.000131

count  total (s)   self (s)
   34   0.001699   0.000116   return neocomplete#helper#complete_check()

FUNCTION  neocomplete#cache#check_old_cache()
Called 1 time
Total time:   0.000923
 Self time:   0.000025

count  total (s)   self (s)
    1   0.000109   0.000010   let cache_dir = neocomplete#get_data_directory() . '/' . a:cache_dir
    1   0.000811   0.000012   return  s:Cache.check_old_cache(cache_dir, a:filename)

FUNCTION  nerdtree#has_opt()
Called 212 times
Total time:   0.000615
 Self time:   0.000615

count  total (s)   self (s)
  212              0.000533     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  neocomplete#helper#is_enabled_source()
Called 64 times
Total time:   0.002032
 Self time:   0.000840

count  total (s)   self (s)
   64   0.000319   0.000295   let source = type(a:source) == type('') ? get(neocomplete#variables#get_sources(), a:source, {}) : a:source
                            
   64   0.001668   0.000500   return !empty(source) && (empty(source.filetypes) ||     neocomplete#helper#check_filetype(source.filetypes))  && (!get(source.disabled_filetypes, '_', 0) &&      !neocomplete#helper#check_filetype(source.disabled_filetypes))

FUNCTION  <SNR>155_restore_statusline()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000003   if &filetype !=# 'unite' || !g:unite_force_overwrite_statusline
    1              0.000000     return
                              endif
                            
                              let unite = unite#get_current_unite()
                            
                              if &l:statusline != unite.statusline
                                " Restore statusline.
                                let &l:statusline = unite.statusline
                              endif

FUNCTION  <SNR>211_compare_source_rank()
Called 10 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
   10              0.000018   return a:i2.rank - a:i1.rank

FUNCTION  neocomplete#sources#tag#make_cache()
Called 1 time
Total time:   0.000135
 Self time:   0.000122

count  total (s)   self (s)
    1   0.000019   0.000006   if !neocomplete#is_enabled()
                                call neocomplete#initialize()
                              endif
                            
    1              0.000003   let bufnumber = bufnr('%')
                            
    1              0.000007   let s:async_tags_list[bufnumber] = []
    1              0.000082   let tagfiles = tagfiles()
    1              0.000003   if get(g:, 'loaded_neoinclude', 0)
                                let tagfiles += neoinclude#include#get_tag_files()
                              endif
    1              0.000006   for tags in map(filter(tagfiles, 'getfsize(v:val) > 0'), "neocomplete#util#substitute_path_separator(    fnamemodify(v:val, ':p'))")
                                if tags !~? '/doc/tags\%(-\w\+\)\?$' && (a:force || getfsize(tags)         < g:neocomplete#sources#tags#cache_limit_size)
                                  call add(s:async_tags_list[bufnumber], s:initialize_tags(tags))
                                endif
                              endfor

FUNCTION  airline#extensions#tabline#default#wrap_name()
Called 442 times
Total time:   0.007088
 Self time:   0.007088

count  total (s)   self (s)
  442              0.001208   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
  442              0.002433   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
  442              0.001591   if getbufvar(a:bufnr, '&modified') == 1
   33              0.000088     let _ .= s:buf_modified_symbol
   33              0.000016   endif
  442              0.000355   return _

FUNCTION  NERDTreeGitStatusRefresh()
Called 2 times
Total time:   0.057237
 Self time:   0.002488

count  total (s)   self (s)
    2              0.000017     let b:NERDTreeCachedGitFileStatus = {}
    2              0.000014     let b:NERDTreeCachedGitDirtyDir   = {}
    2              0.000004     let b:NOT_A_GIT_REPOSITORY        = 1
                            
    2   0.000221   0.000015     let l:root = b:NERDTreeRoot.path.str()
    2              0.000004     let l:gitcmd = 'git -c color.status=false status -s'
    2              0.000006     if exists('g:NERDTreeGitStatusIgnoreSubmodules')
                                    let l:gitcmd = l:gitcmd . ' --ignore-submodules'
                                    if g:NERDTreeGitStatusIgnoreSubmodules ==# 'all' || g:NERDTreeGitStatusIgnoreSubmodules ==# 'dirty' || g:NERDTreeGitStatusIgnoreSubmodules ==# 'untracked'
                                        let l:gitcmd = l:gitcmd . '=' . g:NERDTreeGitStatusIgnoreSubmodules
                                    endif
                                endif
    2   0.052835   0.000588     let l:statusesStr = system('cd ' . l:root . ' && ' . l:gitcmd)
    2              0.000122     let l:statusesSplit = split(l:statusesStr, '\n')
    2              0.000090     if l:statusesSplit != [] && l:statusesSplit[0] =~# 'fatal:.*'
                                    let l:statusesSplit = []
                                    return
                                endif
    2              0.000010     let b:NOT_A_GIT_REPOSITORY = 0
                            
   21              0.000045     for l:statusLine in l:statusesSplit
                                    " cache git status of files
   19              0.000197         let l:pathStr = substitute(l:statusLine, '...', '', '')
   19              0.000143         let l:pathSplit = split(l:pathStr, ' -> ')
   19              0.000050         if len(l:pathSplit) == 2
                                        call s:NERDTreeCacheDirtyDir(l:pathSplit[0])
                                        let l:pathStr = l:pathSplit[1]
                                    else
   19              0.000059             let l:pathStr = l:pathSplit[0]
   19              0.000015         endif
   19   0.000464   0.000143         let l:pathStr = s:NERDTreeTrimDoubleQuotes(l:pathStr)
   19              0.000105         if l:pathStr =~# '\.\./.*'
                                        continue
                                    endif
   19   0.000313   0.000162         let l:statusKey = s:NERDTreeGetFileGitStatusKey(l:statusLine[0], l:statusLine[1])
   19              0.000227         let b:NERDTreeCachedGitFileStatus[fnameescape(l:pathStr)] = l:statusKey
                            
   19   0.001949   0.000125         call s:NERDTreeCacheDirtyDir(l:pathStr)
   19              0.000017     endfor

FUNCTION  <SNR>68_repo()
Called 2 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    2              0.000013   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
    2              0.000002   if dir !=# ''
    2              0.000005     if has_key(s:repos, dir)
    2              0.000006       let repo = get(s:repos, dir)
    2              0.000000     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
    2              0.000011     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  <SNR>145_SID_PREFIX()
Called 67 times
Total time:   0.000595
 Self time:   0.000595

count  total (s)   self (s)
   67              0.000351   if !exists('s:sid_prefix')
                                let s:sid_prefix = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeSID_PREFIX$')
                              endif
   67              0.000054   return s:sid_prefix

FUNCTION  nerdtree#exec()
Called 2 times
Total time:   0.000254
 Self time:   0.000254

count  total (s)   self (s)
    2              0.000017     let old_ei = &ei
    2              0.000019     set ei=all
    2              0.000202     exec a:cmd
    2              0.000014     let &ei = old_ei

FUNCTION  neocomplete#handler#_on_insert_char_pre()
Called 24 times
Total time:   0.002892
 Self time:   0.000977

count  total (s)   self (s)
   24   0.001908   0.000221   if neocomplete#is_cache_disabled()
                                return
                              endif
                            
   24   0.000383   0.000155   let neocomplete = neocomplete#get_current_neocomplete()
   24              0.000162   if neocomplete.old_char != ' ' && v:char == ' ' && v:count == 0
                                call s:make_cache_current_line()
                              endif
                            
   24              0.000096   let neocomplete.old_char = v:char

FUNCTION  GitGutterGetHunkSummary()
Called 70 times
Total time:   0.000367
 Self time:   0.000238

count  total (s)   self (s)
   70   0.000334   0.000205   return gitgutter#hunk#summary()

FUNCTION  432()
Called 2 times
Total time:   0.000040
 Self time:   0.000024

count  total (s)   self (s)
    2              0.000006   let is_force = get(a:000, 0, 0)
                            
                              " everything is loaded, done!
    2   0.000029   0.000013   if !is_force && self.is_loaded && !self.has_external_update()
    2              0.000002     return
                              endif
                            
                              let mru_file = self.mru_file
                            
                              if !filereadable(mru_file)
                                return
                              endif
                            
                              let file = readfile(mru_file)
                              if empty(file)
                                return
                              endif
                            
                              let [ver; items] = file
                              if !self.version_check(ver)
                                return
                              endif
                            
                              if self.type ==# 'file'
                              endif
                            
                              " Assume properly saved and sorted. unique sort is not necessary here
                              call extend(self.candidates, items)
                            
                              if self.is_loaded
                                let self.candidates = s:uniq(self.candidates)
                              endif
                            
                              let self.mtime = getftime(mru_file)
                              let self.is_loaded = 1

FUNCTION  <SNR>157_resolve()
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000016   return g:neomru#follow_links ? resolve(a:fpath) : a:fpath

FUNCTION  <SNR>213_getfilename()
Called 4 times
Total time:   0.000319
 Self time:   0.000042

count  total (s)   self (s)
    4   0.000314   0.000037   return s:_encode_name(a:cache_dir, a:filename)

FUNCTION  <SNR>82__is_quitting()
Called 2 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000002     let quitting = 0
    2              0.000006     if exists('w:syntastic_wid')
                                    let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
                                    let idx = index(s:_quit_pre, key)
                                    if idx >= 0
                                        call remove(s:_quit_pre, idx)
                                        let quitting = 1
                                    endif
                                endif
                            
    2              0.000002     return quitting

FUNCTION  447()
Called 9 times
Total time:   0.002687
 Self time:   0.001990

count  total (s)   self (s)
    9              0.000014   if g:neocomplete#max_keyword_width < 0
                                return a:context.candidates
                              endif
                            
                              " Delimiter check.
   18              0.000047   for delimiter in get(g:neocomplete#delimiter_patterns, a:context.filetype, [])
                                " Count match.
    9              0.000011     let delim_cnt = 0
    9   0.000200   0.000041     let delimiter_vim = neocomplete#util#escape_pattern(delimiter)
    9              0.000048     let matchend = matchend(a:context.complete_str, delimiter_vim)
    9              0.000009     while matchend >= 0
                                  let matchend = matchend(a:context.complete_str, delimiter_vim, matchend)
                                  let delim_cnt += 1
                                endwhile
                            
    9              0.000009     lua << EOF
                                do
                                  local candidates = vim.eval('a:context.candidates')
                                  local pattern = vim.eval('neocomplete#filters#escape(delimiter)')..'.'
                                  for i = 0, #candidates-1 do
                                    if string.find(candidates[i].word, pattern, 1) ~= nil and (
                                        not candidates[i].abbr or
                                        string.gsub(candidates[i].word, '%([^)]*%)?', '()')
                                          == string.gsub(candidates[i].abbr, '%([^)]*%)?', '()')) then
                                      vim.command('call s:process_delimiter(a:context, '..
                                        'a:context.candidates['.. i ..
                                        '], delimiter_vim, delim_cnt)')
                                    end
                                  end
                                end
                            EOF
    9              0.000008   endfor
                            
    9              0.000010   return a:context.candidates

FUNCTION  <SNR>109_get_hunks()
Called 70 times
Total time:   0.003601
 Self time:   0.001275

count  total (s)   self (s)
   70              0.000156   if empty(s:source_func)
                                if get(g:, 'loaded_signify', 0)
                                  let s:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let s:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let s:source_func = 's:get_hunks_changes'
                                else
                                  let s:source_func = 's:get_hunks_empty'
                                endif
                              endif
   70   0.002689   0.000363   return {s:source_func}()

FUNCTION  <SNR>164_get_list()
Called 6 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    6              0.000019   if !exists('s:List')
                                let s:List = neocomplete#util#get_vital().import('Data.List')
                              endif
    6              0.000005   return s:List

FUNCTION  airline#highlighter#exec()
Called 7556 times
Total time:   0.282805
 Self time:   0.282805

count  total (s)   self (s)
 7556              0.010041   let colors = a:colors
 7556              0.006378   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
 7556              0.219304   exec printf('hi %s %s %s %s %s %s %s %s', a:group, get(colors, 0, '') != '' ? 'guifg='.colors[0] : '', get(colors, 1, '') != '' ? 'guibg='.colors[1] : '', get(colors, 2, '') != '' ? 'ctermfg='.colors[2] : '', get(colors, 3, '') != '' ? 'ctermbg='.colors[3] : '', get(colors, 4, '') != '' ? 'gui='.colors[4] : '', get(colors, 4, '') != '' ? 'cterm='.colors[4] : '', get(colors, 4, '') != '' ? 'term='.colors[4] : '')

FUNCTION  neocomplete#handler#_do_auto_complete()
Called 12 times
Total time:   0.059454
 Self time:   0.001338

count  total (s)   self (s)
   12   0.000122   0.000046   let neocomplete = neocomplete#get_current_neocomplete()
                            
   12   0.000652   0.000077   if (g:neocomplete#enable_cursor_hold_i && empty(neocomplete.candidates) && a:event ==# 'CursorMovedI') || s:check_in_do_auto_complete()
                                return
                              endif
                            
   12              0.000021   let neocomplete.skipped = 0
   12              0.000038   let neocomplete.event = a:event
   12   0.000443   0.000054   call neocomplete#helper#clear_result()
                            
                              " Set context filetype.
   12   0.000441   0.000042   call neocomplete#context_filetype#set()
                            
   12   0.001147   0.000054   let cur_text = neocomplete#get_cur_text(1)
   12              0.000016   let complete_pos = -1
                            
   12   0.000113   0.000061   call neocomplete#print_debug('cur_text = ' . cur_text)
                            
   12              0.000073   try
                                " Prevent infinity loop.
   12   0.000459   0.000076     if s:is_skip_auto_complete(cur_text)
    1   0.000006   0.000003       call neocomplete#print_debug('Skipped.')
    1              0.000001       return
                                endif
                            
   11   0.001061   0.000053     let complete_pos = s:check_force_omni(cur_text)
   11              0.000012     if complete_pos >= 0
                                  return
                                endif
                            
                                " Check multibyte input or eskk or spaces.
   11   0.000448   0.000109     if cur_text =~ '^\s*$' || neocomplete#is_eskk_enabled() || neocomplete#is_multibyte_input(cur_text)
    1   0.000006   0.000003       call neocomplete#print_debug('Skipped.')
    1              0.000001       return
                                endif
                            
   10              0.000010     try
   10              0.000018       let neocomplete.is_auto_complete = 1
                            
                                  " Do prefetch.
   10   0.053160   0.000067       let neocomplete.complete_sources = neocomplete#complete#_get_results(cur_text)
   10              0.000008     finally
   10              0.000014       let neocomplete.is_auto_complete = 0
   10              0.000008     endtry
                            
   10              0.000016     if empty(neocomplete.complete_sources)
    4   0.000136   0.000025       call s:check_fallback(cur_text)
    4              0.000004       return
                                endif
                            
                                " Start auto complete.
    6   0.000422   0.000048     call s:complete_key( "\<Plug>(neocomplete_start_auto_complete)")
    6              0.000004   finally
   12   0.000279   0.000061     call neocomplete#complete#_set_previous_position(cur_text, complete_pos)
   12              0.000010   endtry

FUNCTION  gitgutter#utility#not_git_dir()
Called 3 times
Total time:   0.000143
 Self time:   0.000068

count  total (s)   self (s)
    3   0.000138   0.000063   return gitgutter#utility#full_path_to_directory_of_file() !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  gitgutter#utility#full_path_to_directory_of_file()
Called 3 times
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
    3              0.000071   return fnamemodify(s:file, ':p:h')

FUNCTION  gitgutter#diff#run_diff()
Called 3 times
Total time:   0.102759
 Self time:   0.001848

count  total (s)   self (s)
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses; fish doesn't want them.
    3              0.000009   let cmd = s:fish ? '' : '('
                            
    3   0.000019   0.000011   let bufnr = gitgutter#utility#bufnr()
    3              0.000008   let tracked = getbufvar(bufnr, 'gitgutter_tracked')  " i.e. tracked by git
    3              0.000002   if !tracked
                                let cmd .= 'git ls-files --error-unmatch '.gitgutter#utility#shellescape(gitgutter#utility#filename())
                                let cmd .= s:fish ? '; and ' : ' && ('
                              endif
                            
    3              0.000003   if a:realtime
    1   0.000046   0.000013     let blob_name = ':'.gitgutter#utility#shellescape(gitgutter#utility#file_relative_to_repo_root())
    1              0.000004     let blob_file = tempname()
    1              0.000003     let buff_file = tempname()
    1   0.000010   0.000006     let extension = gitgutter#utility#extension()
    1              0.000002     if !empty(extension)
    1              0.000004       let blob_file .= '.'.extension
    1              0.000002       let buff_file .= '.'.extension
    1              0.000001     endif
    1              0.000004     let cmd .= 'git show '.blob_name.' > '.blob_file
    1              0.000003     let cmd .= s:fish ? '; and ' : ' && '
                            
                                " Writing the whole buffer resets the '[ and '] marks and also the
                                " 'modified' flag (if &cpoptions includes '+').  These are unwanted
                                " side-effects so we save and restore the values ourselves.
    1              0.000006     let modified      = getbufvar(bufnr, "&mod")
    1              0.000003     let op_mark_start = getpos("'[")
    1              0.000003     let op_mark_end   = getpos("']")
                            
    1              0.000433     execute 'keepalt silent write' buff_file
                            
    1              0.000013     call setbufvar(bufnr, "&mod", modified)
    1              0.000003     call setpos("'[", op_mark_start)
    1              0.000002     call setpos("']", op_mark_end)
    1              0.000001   endif
                            
    3              0.000015   let cmd .= 'git diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '
    3              0.000002   if a:realtime
    1              0.000003     let cmd .= blob_file.' '.buff_file
    1              0.000001   else
    2   0.000053   0.000013     let cmd .= gitgutter#utility#shellescape(gitgutter#utility#filename())
    2              0.000002   endif
                            
    3              0.000006   if a:use_external_grep && s:grep_available
    3              0.000006     let cmd .= s:grep_command
    3              0.000001   endif
                            
    3              0.000006   if (a:use_external_grep && s:grep_available) || a:realtime
                                " grep exits with 1 when no matches are found; diff exits with 1 when
                                " differences are found.  However we want to treat non-matches and
                                " differences as non-erroneous behaviour; so we OR the command with one
                                " which always exits with success (0).
    3              0.000007     let cmd .= s:fish ? '; or ' : ' || '
    3              0.000005     let cmd .= 'exit 0'
    3              0.000002   endif
                            
    3              0.000002   if !s:fish
    3              0.000003     let cmd .= ')'
                            
    3              0.000003     if !tracked
                                  let cmd .= ')'
                                endif
    3              0.000002   end
                            
    3   0.100769   0.000105   let diff = gitgutter#utility#system(gitgutter#utility#command_in_directory_of_file(cmd))
                            
    3              0.000008   if a:realtime
    1              0.000090     call delete(blob_file)
    1              0.000077     call delete(buff_file)
    1              0.000688     execute 'keepalt silent! bwipeout' buff_file
    1              0.000002   endif
                            
    3   0.000224   0.000062   if gitgutter#utility#shell_error()
                                " A shell error indicates the file is not tracked by git (unless something bizarre is going on).
                                throw 'diff failed'
                              endif
                            
    3              0.000005   if !tracked
                                call setbufvar(bufnr, 'gitgutter_tracked', 1)
                              endif
                            
    3              0.000007   return diff

FUNCTION  neocomplete#helper#get_cur_text()
Called 39 times
Total time:   0.002936
 Self time:   0.002681

count  total (s)   self (s)
   39   0.000388   0.000133   let neocomplete = neocomplete#get_current_neocomplete()
   39              0.000115   let is_skip_char = get(a:000, 0, 0)
                            
   39              0.000927   let cur_text = ((neocomplete.event ==# 'InsertEnter' || mode() ==# 'i') ?   (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . (mode() ==# 'i' && !is_skip_char ?                    col('.') : col('.') - 1)         . 'c' . (mode() ==# 'i' ? '' : '.'))
                            
   39              0.000421   if cur_text =~ '^.\{-}\ze\S\+$'
   38              0.000260     let complete_str = matchstr(cur_text, '\S\+$')
   38              0.000261     let cur_text = matchstr(cur_text, '^.\{-}\ze\S\+$')
   38              0.000030   else
    1              0.000001     let complete_str = ''
    1              0.000001   endif
                            
   39              0.000063   if neocomplete.event ==# 'InsertCharPre'
                                let complete_str .= v:char
                              endif
                            
   39              0.000114   let neocomplete.cur_text = cur_text . complete_str
                            
                              " Save cur_text.
   39              0.000047   return neocomplete.cur_text

FUNCTION  nerdtree#renderView()
Called 2 times
Total time:   0.055738
 Self time:   0.000014

count  total (s)   self (s)
    2   0.055736   0.000012     call b:NERDTree.render()

FUNCTION  neocomplete#cache#check_cache()
Called 9 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
    9              0.000026   if !has_key(a:async_cache_dictionary, a:key)
    8              0.000006     return
                              endif
                            
    1              0.000004   let cache_list = a:async_cache_dictionary[a:key]
                            
    1              0.000002   if !has_key(a:keyword_cache, a:key)
                                let a:keyword_cache[a:key] = []
                              endif
    1              0.000005   for cache in filter(copy(cache_list), 'filereadable(v:val.cachename)')
                                let a:keyword_cache[a:key] += neocomplete#cache#load_from_cache( a:cache_dir, cache.filename, a:is_string)
                              endfor
                            
    1              0.000003   call filter(cache_list, '!filereadable(v:val.cachename)')
                            
    1              0.000002   if empty(cache_list)
                                " Delete from dictionary.
    1              0.000027     call remove(a:async_cache_dictionary, a:key)
    1              0.000001     return
                              endif

FUNCTION  SyntasticBalloonsExprNotifier()
Called 3 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
    3              0.000048     if !exists('b:syntastic_private_balloons')
    3              0.000009         return ''
                                endif
                                return get(b:syntastic_private_balloons, v:beval_lnum, '')

FUNCTION  <SNR>171_should_create_cache()
Called 7 times
Total time:   0.000373
 Self time:   0.000373

count  total (s)   self (s)
    7              0.000265   let filepath = fnamemodify(bufname(a:bufnr), ':p')
    7              0.000099   return getfsize(filepath) < g:neocomplete#sources#buffer#cache_limit_size && getbufvar(a:bufnr, '&modifiable') && !getwinvar(bufwinnr(a:bufnr), '&previewwindow') && (g:neocomplete#sources#buffer#disabled_pattern == ''  || filepath !~# g:neocomplete#sources#buffer#disabled_pattern)

FUNCTION  neocomplete#get_data_directory()
Called 6 times
Total time:   0.000585
 Self time:   0.000258

count  total (s)   self (s)
    6              0.000055   let g:neocomplete#data_directory = get(g:, 'neocomplete#data_directory',  ($XDG_CACHE_HOME != '' ?   $XDG_CACHE_HOME . '/neocomplete' : '~/.cache/neocomplete'))
    6   0.000394   0.000067   let directory = neocomplete#util#substitute_path_separator( neocomplete#util#expand(g:neocomplete#data_directory))
    6              0.000023   if !isdirectory(directory)
                                if neocomplete#util#is_sudo()
                                  call neocomplete#print_error(printf( 'Cannot create Directory "%s" in sudo session.', directory))
                                else
                                  call mkdir(directory, 'p')
                                endif
                              endif
                            
    6              0.000008   return directory

FUNCTION  <SNR>119_get_seperator()
Called 54 times
Total time:   0.008367
 Self time:   0.000500

count  total (s)   self (s)
   54   0.004335   0.000211   if s:should_change_group(a:prev_group, a:group)
   12   0.003804   0.000061     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
   42              0.000079     return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  271()
Called 1 time
Total time:   0.000028
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000007   0.000002     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
    1   0.000009   0.000002     let auto_loc_list = syntastic#util#var('auto_loc_list')
    1   0.000003   0.000001     if !a:loclist.isEmpty()
                                    if auto_loc_list == 1 || auto_loc_list == 3
                                        call a:loclist.show()
                                    endif
                                else
    1              0.000001         if auto_loc_list == 1 || auto_loc_list == 2
                                        "TODO: this will close the loc list window if one was opened by
                                        "something other than syntastic
    1              0.000001             lclose
    1              0.000000         endif
    1              0.000000     endif

FUNCTION  gitgutter#hunk#summary()
Called 70 times
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
   70              0.000092   return s:summary

FUNCTION  gitgutter#utility#shell_error()
Called 3 times
Total time:   0.000162
 Self time:   0.000061

count  total (s)   self (s)
    3   0.000151   0.000050   return gitgutter#utility#using_xolox_shell() ? s:exit_code : v:shell_error

FUNCTION  <SNR>119_get_accented_line()
Called 66 times
Total time:   0.002187
 Self time:   0.002187

count  total (s)   self (s)
   66              0.000078   if a:self._context.active
   66              0.000069     let contents = []
   66              0.000322     let content_parts = split(a:contents, '__accent')
  120              0.000140     for cpart in content_parts
   54              0.000347       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   54              0.000117       call add(contents, cpart)
   54              0.000031     endfor
   66              0.000146     let line = join(contents, a:group)
   66              0.000299     let line = substitute(line, '__restore__', a:group, 'g')
   66              0.000034   else
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
                              endif
   66              0.000043   return line

FUNCTION  neocomplete#util#expand()
Called 6 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
    6              0.000084   return expand(escape(a:path, '*?[]"={}'), 1)

FUNCTION  <SNR>113_check_mixed_indent()
Called 2 times
Total time:   0.000234
 Self time:   0.000234

count  total (s)   self (s)
    2              0.000005   if s:indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less then tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              else
    2              0.000217     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  <SNR>145_encode_size()
Called 24 times
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
                              " Set each bit7 to 1 in order to avoid NUL byte.
   24              0.000113   return printf("%c%c%c%c%c", ((a:n / 0x10000000) % 0x80) + 0x80, ((a:n / 0x200000) % 0x80) + 0x80, ((a:n / 0x4000) % 0x80) + 0x80, ((a:n / 0x80) % 0x80) + 0x80, ( a:n % 0x80) + 0x80)

FUNCTION  209()
Called 20 times
Total time:   0.000366
 Self time:   0.000222

count  total (s)   self (s)
   20   0.000232   0.000088     let flags = self._flagsForScope(a:scope)
   20              0.000046     if index(flags, a:flag) == -1
   20              0.000048         call add(flags, a:flag)
   20              0.000017     end

FUNCTION  unite#get_current_unite()
Called 1 time
Total time:   0.000020
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000019   0.000010   return exists('b:unite') && !unite#variables#use_current_unite() ? b:unite : unite#variables#current_unite()

FUNCTION  <SNR>145_plineopen()
Called 1 time
Total time:   0.005770
 Self time:   0.000862

count  total (s)   self (s)
    1              0.000003   let pid_list = []
    1              0.000002   let stdin_list = []
    1              0.000001   let stdout_list = []
    1              0.000002   let stderr_list = []
    1              0.000001   let npipe = a:npipe
                            
                              " Open input.
    1              0.000006   let hstdin = (empty(a:commands) || a:commands[0].fd.stdin == '')? 0 : vimproc#fopen(a:commands[0].fd.stdin, 'r').fd
                            
    1   0.000010   0.000008   let is_pty = !vimproc#util#is_windows() && a:is_pty
                            
    1              0.000001   let cnt = 0
    2              0.000008   for command in a:commands
    1              0.000003     if is_pty && command.fd.stdout == '' && cnt == 0 && len(a:commands) != 1
                                  " pty_open() use pipe.
                                  let hstdout = 1
                                else
    1              0.000007       if command.fd.stdout =~ '^>'
                                    let mode = 'a'
                                    let command.fd.stdout = command.fd.stdout[1:]
                                  else
    1              0.000004         let mode = 'w'
    1              0.000002       endif
                            
    1   0.000025   0.000009       let hstdout = s:is_pseudo_device(command.fd.stdout) ? 0 : vimproc#fopen(command.fd.stdout, mode).fd
    1              0.000001     endif
                            
    1              0.000002     if is_pty && command.fd.stderr == '' && cnt == 0 && len(a:commands) != 1
                                  " pty_open() use pipe.
                                  let hstderr = 1
                                else
    1              0.000004       if command.fd.stderr =~ '^>'
                                    let mode = 'a'
                                    let command.fd.stderr = command.fd.stderr[1:]
                                  else
    1              0.000002         let mode = 'w'
    1              0.000002       endif
    1   0.000015   0.000005       let hstderr = s:is_pseudo_device(command.fd.stderr) ? 0 : vimproc#fopen(command.fd.stderr, mode).fd
    1              0.000000     endif
                            
    1              0.000004     if command.fd.stderr ==# '/dev/stdout'
                                  let npipe = 2
                                endif
                            
    1   0.000663   0.000010     let args = s:convert_args(command.args)
    1              0.000005     let command_name = fnamemodify(args[0], ':t:r')
    1              0.000008     let pty_npipe = cnt == 0 && hstdin == 0 && hstdout == 0 && hstderr == 0 && exists('g:vimproc#popen2_commands') && get(g:vimproc#popen2_commands, command_name, 0) != 0 ? 2 : npipe
                            
    1              0.000002     if is_pty && (cnt == 0 || cnt == len(a:commands)-1)
                                  " Use pty_open().
                                  let pipe = s:vp_pty_open(pty_npipe, s:get_winwidth(), winheight(0), hstdin, hstdout, hstderr, args)
                                else
    1   0.003365   0.000033       let pipe = s:vp_pipe_open(pty_npipe, hstdin, hstdout, hstderr, args)
    1              0.000001     endif
                            
    1              0.000002     if len(pipe) == 4
                                  let [pid, fd_stdin, fd_stdout, fd_stderr] = pipe
                                  let stderr = s:fdopen(fd_stderr, 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
                                else
    1              0.000003       let [pid, fd_stdin, fd_stdout] = pipe
    1   0.000202   0.000023       let stderr = s:closed_fdopen( 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
    1              0.000000     endif
                            
    1              0.000007     call add(pid_list, pid)
    1   0.000174   0.000018     let stdin = s:fdopen(fd_stdin, 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
    1              0.000104     let stdin.is_pty = is_pty && (cnt == 0 || cnt == len(a:commands)-1) && hstdin == 0
    1              0.000113     call add(stdin_list, stdin)
    1   0.000431   0.000161     let stdout = s:fdopen(fd_stdout, 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
    1              0.000006     let stdout.is_pty = is_pty && (cnt == 0 || cnt == len(a:commands)-1) && hstdout == 0
    1              0.000004     call add(stdout_list, stdout)
    1              0.000004     let stderr.is_pty = is_pty && (cnt == 0 || cnt == len(a:commands)-1) && hstderr == 0
    1              0.000004     call add(stderr_list, stderr)
                            
    1              0.000005     let hstdin = stdout_list[-1].fd
    1              0.000004     let cnt += 1
    1              0.000001   endfor
                            
    1              0.000001   let proc = {}
    1              0.000002   let proc.pid_list = pid_list
    1              0.000002   let proc.pid = pid_list[-1]
    1   0.000093   0.000010   let proc.stdin = s:fdopen_pipes(stdin_list, 'vp_pipes_close', 'read_pipes', 'write_pipes')
    1   0.000083   0.000004   let proc.stdout = s:fdopen_pipes(stdout_list, 'vp_pipes_close', 'read_pipes', 'write_pipes')
    1   0.000083   0.000004   let proc.stderr = s:fdopen_pipes(stderr_list, 'vp_pipes_close', 'read_pipes', 'write_pipes')
    1   0.000013   0.000003   let proc.get_winsize = s:funcref('vp_get_winsize')
    1   0.000012   0.000003   let proc.set_winsize = s:funcref('vp_set_winsize')
    1   0.000013   0.000003   let proc.kill = s:funcref('vp_kill')
    1   0.000012   0.000002   let proc.waitpid = s:funcref('vp_waitpid')
    1   0.000013   0.000003   let proc.checkpid = s:funcref('vp_checkpid')
    1              0.000002   let proc.is_valid = 1
    1              0.000002   let proc.is_pty = is_pty
    1              0.000001   if a:is_pty
                                let proc.ttyname = ''
                                let proc.width = winwidth(0) - &l:numberwidth - &l:foldcolumn
                                let proc.height = winheight(0)
                                let proc.get_winsize = s:funcref('vp_get_winsize')
                                let proc.set_winsize = s:funcref('vp_set_winsize')
                              endif
                            
    1              0.000056   return proc

FUNCTION  neocomplete#handler#_on_insert_leave()
Called 2 times
Total time:   0.006986
 Self time:   0.000048

count  total (s)   self (s)
    2   0.000089   0.000009   call neocomplete#helper#clear_result()
                            
    2   0.000109   0.000009   call s:close_preview_window()
    2   0.006758   0.000014   call s:make_cache_current_line()
                            
    2   0.000021   0.000007   let neocomplete = neocomplete#get_current_neocomplete()
    2              0.000004   let neocomplete.cur_text = ''

FUNCTION  neocomplete#variables#get_sources()
Called 4 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    4              0.000010   if !exists('s:sources')
                                let s:sources = {}
                              endif
    4              0.000004   return s:sources

FUNCTION  <SNR>185_check_fallback()
Called 4 times
Total time:   0.000111
 Self time:   0.000086

count  total (s)   self (s)
    4              0.000007   let cur_text = a:cur_text
    4              0.000028   let complete_pos = match(cur_text, '\h\w*$')
    4   0.000042   0.000017   let neocomplete = neocomplete#get_current_neocomplete()
    4              0.000026   if empty(g:neocomplete#fallback_mappings) || len(matchstr(cur_text, '\h\w*$'))   < g:neocomplete#auto_completion_start_length || neocomplete.skip_next_complete || neocomplete#complete#_check_previous_position(      cur_text, complete_pos)
    4              0.000002     return
                              endif
                            
                              let key = ''
                              for i in range(0, len(g:neocomplete#fallback_mappings)-1)
                                let key .= '<C-r>=neocomplete#mappings#fallback(' . i . ')<CR>'
                              endfor
                              execute 'inoremap <silent> <Plug>(neocomplete_fallback)' key
                            
                              " Fallback
                              call s:complete_key("\<Plug>(neocomplete_fallback)")

FUNCTION  syntastic#util#var()
Called 23 times
Total time:   0.000172
 Self time:   0.000172

count  total (s)   self (s)
   23              0.000155     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''

FUNCTION  gitgutter#utility#bufnr()
Called 17 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
   17              0.000028   return s:bufnr

FUNCTION  <SNR>147_which()
Called 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000007   let maxcount = (a:0 >= 2 && type(a:2) == type(0)) ? a:2 : 1
    1              0.000003   if maxcount == 1 && exists('*exepath')
    1              0.000024     let full = exepath(a:command)
    1              0.000003     if s:is_windows && (full =~? '\.lnk$') && (getftype(full) ==# 'file')
                                  return resolve(full)
                                endif
    1              0.000001     return full
                              endif
                              let pathlist = a:command =~# s:path_sep_pattern ? [''] :              !a:0                  ? split($PATH, s:path_separator) :              type(a:1) == type([]) ? copy(a:1) :                                      split(a:1, s:path_separator)
                              let pathlist = vimproc#util#uniq(pathlist)
                            
                              let pathext = s:path_extensions()
                              if index(pathext, '.' . tolower(fnamemodify(a:command, ':e'))) != -1
                                let pathext = ['']
                              endif
                            
                              let dirsep = s:separator()
                              let cmdlist = []
                              for dir in pathlist
                                let head = dir ==# '' ? '' : dir . dirsep
                                for ext in pathext
                                  let full = fnamemodify(head . a:command . ext, ':p')
                                  if s:is_windows && (full =~? '\.lnk$') && (getftype(full) ==# 'file')
                                    let full = resolve(full)
                                  endif
                            
                                  if executable(full)
                                    if s:is_case_tolerant()
                                      let full = glob(substitute(               vimproc#util#substitute_path_separator( toupper(full)), '\u:\@!', '[\0\L\0]', 'g'), 1)
                                    endif
                                    if full != ''
                                      let cmdlist += [full]
                                      if maxcount > 0 && len(cmdlist) >= maxcount
                                        return join(cmdlist, "\n")
                                      endif
                                    endif
                                  endif
                                endfor
                              endfor
                            
                              return join(cmdlist, "\n")

FUNCTION  210()
Called 72 times
Total time:   0.000475
 Self time:   0.000475

count  total (s)   self (s)
   72              0.000448     let self._flags[a:scope] = []

FUNCTION  211()
Called 20 times
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
   20              0.000063     if !has_key(self._flags, a:scope)
                                    let self._flags[a:scope] = []
                                endif
   20              0.000033     return self._flags[a:scope]

FUNCTION  212()
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000014     let newObj = copy(self)
    1              0.000003     let newObj._flags = {}
    1              0.000001     return newObj

FUNCTION  214()
Called 106 times
Total time:   0.001712
 Self time:   0.001712

count  total (s)   self (s)
  106              0.000141     let flagstring = ""
  212              0.000483     for i in values(self._flags)
  106              0.000283         let flagstring .= join(i)
  106              0.000070     endfor
                            
  106              0.000187     if len(flagstring) == 0
   71              0.000056         return ""
                                endif
                            
   35              0.000063     return '[' . flagstring . ']'

FUNCTION  <SNR>91_Highlight_Matching_Pair()
Called 39 times
Total time:   0.002659
 Self time:   0.002659

count  total (s)   self (s)
                              " Remove any previous match.
   39              0.000179   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   39              0.000270   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   39              0.000111   let c_lnum = line('.')
   39              0.000106   let c_col = col('.')
   39              0.000048   let before = 0
                            
   39              0.000099   let text = getline(c_lnum)
   39              0.000115   let c = text[c_col - 1]
   39              0.000557   let plist = split(&matchpairs, '.\zs[:,]')
   39              0.000114   let i = index(plist, c)
   39              0.000040   if i < 0
                                " not found, in Insert mode try character before the cursor
   39              0.000142     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   20              0.000036       let before = 1
   20              0.000053       let c = text[c_col - 2]
   20              0.000046       let i = index(plist, c)
   20              0.000015     endif
   39              0.000036     if i < 0
                                  " not found, nothing to do
   39              0.000033       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>145_pgroup_open()
Called 1 time
Total time:   0.006528
 Self time:   0.000218

count  total (s)   self (s)
    1              0.000005   let proc = {}
                            
    1              0.000012   let cwd = getcwd()
    1              0.000001   try
    1   0.000124   0.000013     call vimproc#util#cd(a:statements[0].cwd)
                            
    1   0.005968   0.000127     let proc.current_proc = vimproc#plineopen{a:npipe}(a:statements[0].statement, a:is_pty)
    1              0.000003   finally
    1   0.000126   0.000006     call vimproc#util#cd(cwd)
    1              0.000002   endtry
                            
    1              0.000003   let proc.pid = proc.current_proc.pid
    1              0.000002   let proc.pid_list = proc.current_proc.pid_list
    1              0.000003   let proc.condition = a:statements[0].condition
    1              0.000003   let proc.statements = a:statements[1:]
    1   0.000084   0.000010   let proc.stdin = s:fdopen_pgroup(proc, proc.current_proc.stdin, 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
    1   0.000073   0.000004   let proc.stdout = s:fdopen_pgroup(proc, proc.current_proc.stdout, 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
    1   0.000077   0.000004   let proc.stderr = s:fdopen_pgroup(proc, proc.current_proc.stderr, 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
    1   0.000014   0.000003   let proc.kill = s:funcref('vp_pgroup_kill')
    1   0.000016   0.000005   let proc.waitpid = s:funcref('vp_pgroup_waitpid')
    1              0.000002   let proc.is_valid = 1
    1              0.000002   let proc.is_pty = 0
                              " echomsg expand('<sfile>')
                              " echomsg 'open:' string(map(copy(proc.current_proc.stdin.fd), 'v:val.fd'))
                              " echomsg 'open:' string(map(copy(proc.current_proc.stdout.fd), 'v:val.fd'))
                              " echomsg 'open:' string(map(copy(proc.current_proc.stderr.fd), 'v:val.fd'))
                            
    1              0.000001   return proc

FUNCTION  <SNR>212_async_load()
Called 1 time
Total time:   0.007790
 Self time:   0.000160

count  total (s)   self (s)
                              " if 0
    1   0.000037   0.000009   if neocomplete#has_vimproc()
    1   0.000031   0.000023     let vim_path = s:search_vim_path()
                            
    1              0.000004     if vim_path == ''
                                  " Error
                                  return
                                elseif !executable(vim_path)
                                  call neocomplete#print_error( printf('Vim path : "%s" is not executable.', vim_path))
                                  let g:neocomplete#use_vimproc = 0
                                  return
                                endif
                            
    1              0.000031     let args = [vim_path, '-u', 'NONE', '-i', 'NONE', '-n',       '-N', '-S', s:sdir.'/async_cache.vim'] + a:argv
    1   0.007260   0.000029     call vimproc#system_bg(args)
                                " call vimproc#system(args)
                                " call system(join(args))
    1              0.000000   else
                                call neocomplete#async_cache#main(a:argv)
                              endif
                            
    1   0.000371   0.000008   return neocomplete#cache#encode_name(a:cache_dir, a:filename)

FUNCTION  neocomplete#complete#_set_results_words()
Called 6 times
Total time:   0.037471
 Self time:   0.003752

count  total (s)   self (s)
                              " Try source completion.
                            
                              " Save options.
    6              0.000013   let ignorecase_save = &ignorecase
    6              0.000022   let pos = winsaveview()
                            
    6              0.000005   try
   25              0.000032     for source in a:sources
   19   0.001116   0.000057       if neocomplete#complete_check()
                                    return
                                  endif
                            
   19              0.000029       let context = source.neocomplete__context
                            
   19              0.000163       let &ignorecase = (g:neocomplete#enable_smart_case || g:neocomplete#enable_camel_case) ?   context.complete_str !~ '\u' : g:neocomplete#enable_ignore_case
                            
   19   0.000402   0.000080       if s:use_previous_result(source, context)
                                    " Use previous candidates.
    6              0.001154         let context.candidates = deepcopy(context.prev_candidates)
    6              0.000004       else
   13              0.000012         try
   13   0.023347   0.000096           let context.candidates = source.gather_candidates(context)
   13              0.000011         catch
                                      call neocomplete#print_error(v:throwpoint)
                                      call neocomplete#print_error(v:exception)
                                      call neocomplete#print_error( 'Source name is ' . source.name)
                                      call neocomplete#print_error( 'Error occurred in source''s gather_candidates()!')
                            
                                      return
                                    finally
   13              0.000060           if winsaveview() != pos
                                        call winrestview(pos)
                                      endif
   13              0.000009         endtry
                            
   13              0.000027         let context.prev_line = context.input
   13              0.000892         let context.prev_candidates = copy(context.candidates)
   13              0.000022         let context.prev_complete_pos = context.complete_pos
   13              0.000005       endif
                            
   19              0.000029       if !empty(context.candidates)
   13   0.000165   0.000080         let matchers = empty(source.neocomplete__matchers) ?   neocomplete#get_current_neocomplete().default_matchers : source.neocomplete__matchers
   13   0.008994   0.000069         let context.candidates = neocomplete#helper#call_filters( matchers, source, {})
   13              0.000011       endif
                            
   19   0.000174   0.000097       call neocomplete#print_debug(source.name)
   19              0.000015     endfor
    6              0.000005   finally
    6              0.000024     let &ignorecase = ignorecase_save
    6              0.000005   endtry

FUNCTION  airline#extensions#branch#head()
Called 140 times
Total time:   0.001049
 Self time:   0.000866

count  total (s)   self (s)
  140              0.000535   if exists('b:airline_head') && !empty(b:airline_head)
  139              0.000149     return b:airline_head
                              endif
                            
    1              0.000001   let b:airline_head = ''
    1              0.000002   let found_fugitive_head = 0
                            
    1              0.000003   if s:has_fugitive && !exists('b:mercurial_dir')
    1   0.000196   0.000013     let b:airline_head = fugitive#head(7)
    1              0.000001     let found_fugitive_head = 1
                            
    1              0.000003     if empty(b:airline_head) && !exists('b:git_dir')
                                  let b:airline_head = s:get_git_branch(expand("%:p:h"))
                                endif
    1              0.000000   endif
                            
    1              0.000001   if empty(b:airline_head)
                                if s:has_lawrencium
                                  let b:airline_head = lawrencium#statusline()
                                endif
                              endif
                            
    1              0.000002   if empty(b:airline_head)
                                if s:has_vcscommand
                                  call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = get(b:VCSCommandBufferInfo, 0, '')
                                  endif
                                endif
                              endif
                            
    1              0.000003   if empty(b:airline_head) || !found_fugitive_head && !s:check_in_path()
                                let b:airline_head = ''
                              endif
                            
    1              0.000002   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:w:displayed_head_limit - 1].'…'
                                endif
                              endif
                            
    1              0.000001   return b:airline_head

FUNCTION  syntastic#log#debugDump()
Called 1 time
Total time:   0.000006
 Self time:   0.000004

count  total (s)   self (s)
    1   0.000005   0.000003     if !s:_isDebugEnabled(a:level)
    1              0.000000         return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )

FUNCTION  <SNR>185_check_in_do_auto_complete()
Called 12 times
Total time:   0.000575
 Self time:   0.000124

count  total (s)   self (s)
   12   0.000490   0.000039   if neocomplete#is_locked()
                                return 1
                              endif
                            
                              " Detect completefunc.
   12              0.000030   if &l:completefunc != '' && &l:buftype =~ 'nofile'
                                return 1
                              endif

FUNCTION  <SNR>82__os_name()
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    2              0.000004     return g:_SYNTASTIC_UNAME

FUNCTION  220()
Called 2 times
Total time:   0.001684
 Self time:   0.000049

count  total (s)   self (s)
    2   0.000749   0.000011     call g:NERDTree.MustBeOpen()
    2   0.000932   0.000035     call nerdtree#exec(g:NERDTree.GetWinNum() . "wincmd w")

FUNCTION  226()
Called 6 times
Total time:   0.002131
 Self time:   0.002131

count  total (s)   self (s)
    6              0.000029     if exists("t:NERDTreeBufName")
    6              0.002086         return bufwinnr(t:NERDTreeBufName)
                                endif
                            
                                return -1

FUNCTION  227()
Called 4 times
Total time:   0.001517
 Self time:   0.000029

count  total (s)   self (s)
    4   0.001515   0.000027     return s:NERDTree.GetWinNum() != -1

FUNCTION  <SNR>145_close()
Called 9 times
Total time:   0.001316
 Self time:   0.000036

count  total (s)   self (s)
    9              0.000006   if self.is_valid
    8   0.000409   0.000066     call self.f_close()
    8              0.000005   endif
                            
    9              0.000008   let self.is_valid = 0
    9              0.000007   let self.eof = 1
    9              0.000006   let self.__eof = 1

FUNCTION  364()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000003     if !exists('b:syntastic_private_sign_ids')
                                    let b:syntastic_private_sign_ids = []
                                endif
    1              0.000001     return b:syntastic_private_sign_ids

FUNCTION  <SNR>213_writefile()
Called 1 time
Total time:   0.000930
 Self time:   0.000891

count  total (s)   self (s)
    1   0.000043   0.000004   let cache_name = s:_encode_name(a:cache_dir, a:filename)
                            
    1              0.000885   call writefile(a:list, cache_name)

FUNCTION  airline#parts#mode()
Called 70 times
Total time:   0.000255
 Self time:   0.000255

count  total (s)   self (s)
   70              0.000201   return get(w:, 'airline_current_mode', '')

FUNCTION  438()
Called 13 times
Total time:   0.007005
 Self time:   0.006691

count  total (s)   self (s)
   13              0.000034   if len(a:context.complete_str) > 10
                                " Mix fuzzy mode.
                                let len = len(a:context.complete_str)
                                let fuzzy_len = len - len/(1 + len/10)
                                let pattern = neocomplete#filters#escape(     a:context.complete_str[: fuzzy_len-1])  . neocomplete#filters#fuzzy_escape(     a:context.complete_str[fuzzy_len :])
                              else
   13   0.000376   0.000062     let pattern = neocomplete#filters#fuzzy_escape( a:context.complete_str)
   13              0.000007   endif
                            
                              " The first letter must be matched.
   13              0.000027   let pattern = '^' . pattern
                            
   13              0.000012   lua << EOF
                            do
                              local pattern = vim.eval('pattern')
                              local input = vim.eval('a:context.complete_str')
                              local candidates = vim.eval('a:context.candidates')
                              if vim.eval('&ignorecase') ~= 0 then
                                pattern = string.lower(pattern)
                                input = string.lower(input)
                                for i = #candidates-1, 0, -1 do
                                  local word = vim.type(candidates[i]) == 'dict' and
                                    string.lower(candidates[i].word) or string.lower(candidates[i])
                                  if string.find(word, pattern, 1) == nil then
                                    candidates[i] = nil
                                  end
                                end
                              else
                                for i = #candidates-1, 0, -1 do
                                  local word = vim.type(candidates[i]) == 'dict' and
                                    candidates[i].word or candidates[i]
                                  if string.find(word, pattern, 1) == nil then
                                    candidates[i] = nil
                                  end
                                end
                              end
                            end
                            EOF
                            
   13              0.000023   return a:context.candidates

FUNCTION  439()
Called 13 times
Total time:   0.001195
 Self time:   0.001195

count  total (s)   self (s)
   13              0.000025   if empty(a:context.candidates)
    2              0.000002     return []
                              endif
                            
   11              0.000006   lua << EOF
                            do
                              local candidates = vim.eval('a:context.candidates')
                              local len = string.len(vim.eval('a:context.complete_str'))
                              for i = #candidates-1, 0, -1 do
                                local word = vim.type(candidates[i]) == 'dict' and
                                candidates[i].word or candidates[i]
                                if string.len(word) <= len then
                                  candidates[i] = nil
                                end
                              end
                            end
                            EOF
                            
   11              0.000014   return a:context.candidates

FUNCTION  <SNR>109_is_branch_empty()
Called 70 times
Total time:   0.001233
 Self time:   0.000535

count  total (s)   self (s)
   70   0.001198   0.000500   return exists('*airline#extensions#branch#head') && empty(airline#extensions#branch#head())

FUNCTION  neocomplete#helper#complete_configure()
Called 6 times
Total time:   0.000313
 Self time:   0.000249

count  total (s)   self (s)
    6              0.000037   set completeopt-=menu
    6              0.000016   set completeopt-=longest
    6              0.000013   set completeopt+=menuone
                            
                              " Set options.
    6   0.000062   0.000025   let neocomplete = neocomplete#get_current_neocomplete()
    6              0.000024   let neocomplete.completeopt = &completeopt
                            
    6   0.000082   0.000055   if neocomplete#util#is_complete_select() && &completeopt !~# 'noinsert\|noselect'
    6              0.000006     if g:neocomplete#enable_auto_select
                                  set completeopt-=noselect
                                  set completeopt+=noinsert
                                else
    6              0.000014       set completeopt-=noinsert
    6              0.000016       set completeopt+=noselect
    6              0.000003     endif
    6              0.000002   endif

FUNCTION  <SNR>56_NERDTreeTrimDoubleQuotes()
Called 38 times
Total time:   0.000637
 Self time:   0.000637

count  total (s)   self (s)
   38              0.000303     let l:toReturn = substitute(a:pathStr, '^"', '', '')
   38              0.000226     let l:toReturn = substitute(l:toReturn, '"$', '', '')
   38              0.000058     return l:toReturn

FUNCTION  321()
Called 1 time
Total time:   0.000087
 Self time:   0.000029

count  total (s)   self (s)
    1   0.000008   0.000004     call self.setOwner(bufnr(''))
    1   0.000025   0.000008     let self._stamp = syntastic#util#stamp()
    2   0.000041   0.000004     for buf in self.getBuffers()
    1              0.000009         call setbufvar(buf, 'syntastic_loclist', self)
    1              0.000001     endfor

FUNCTION  230()
Called 2 times
Total time:   0.000738
 Self time:   0.000024

count  total (s)   self (s)
    2   0.000730   0.000016     if !s:NERDTree.IsOpen()
                                    throw "NERDTree.TreeNotOpen"
                                endif

FUNCTION  232()
Called 350 times
Total time:   0.001994
 Self time:   0.001994

count  total (s)   self (s)
  350              0.000888     if !exists('s:NERDTree._PathFilters')
                                    let s:NERDTree._PathFilters = []
                                endif
  350              0.000371     return s:NERDTree._PathFilters

FUNCTION  234()
Called 2 times
Total time:   0.055724
 Self time:   0.000021

count  total (s)   self (s)
    2   0.055722   0.000019     call self.ui.render()

FUNCTION  236()
Called 2 times
Total time:   0.000304
 Self time:   0.000287

count  total (s)   self (s)
    2              0.000009     let old_h = @h
    2   0.000027   0.000017     if self.getShowHelp()
                                    let @h=   "\" NERD tree (" . nerdtree#version() . ") quickhelp~\n"
                                    let @h=@h."\" ============================\n"
                                    let @h=@h."\" File node mappings~\n"
                                    let @h=@h."\" ". (g:NERDTreeMouseMode ==# 3 ? "single" : "double") ."-click,\n"
                                    let @h=@h."\" <CR>,\n"
                                    if self.nerdtree.isTabTree()
                                        let @h=@h."\" ". g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let @h=@h."\" ". g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let @h=@h."\" ". g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let @h=@h."\" middle-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenSplit .": open split\n"
                                    let @h=@h."\" ". g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let @h=@h."\" ". g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Directory node mappings~\n"
                                    let @h=@h."\" ". (g:NERDTreeMouseMode ==# 1 ? "double" : "single") ."-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapActivateNode .": open & close node\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let @h=@h."\" ". g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let @h=@h."\" ". g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let @h=@h."\"    current node recursively\n"
                                    let @h=@h."\" middle-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Bookmark table mappings~\n"
                                    let @h=@h."\" double-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let @h=@h."\" ". g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Tree navigation mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpRoot .": go to root\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpParent .": go to parent\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Filesystem mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let @h=@h."\"    selected dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let @h=@h."\"    but leave old root open\n"
                                    let @h=@h."\" ". g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let @h=@h."\" ". g:NERDTreeMapMenu .": Show menu\n"
                                    let @h=@h."\" ". g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let @h=@h."\"    selected dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Tree filtering mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleHidden .": hidden files (" . (self.getShowHidden() ? "on" : "off") . ")\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleFilters .": file filters (" . (self.isIgnoreFilterEnabled() ? "on" : "off") . ")\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleFiles .": files (" . (self.getShowFiles() ? "on" : "off") . ")\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleBookmarks .": bookmarks (" . (self.getShowBookmarks() ? "on" : "off") . ")\n"
                            
                                    "add quickhelp entries for each custom key map
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let @h=@h."\" ". i.key .": ". i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Other mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let @h=@h."\"    the NERDTree window\n"
                                    let @h=@h."\" ". g:NERDTreeMapHelp .": toggle help\n"
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Bookmark commands~\n"
                                    let @h=@h."\" :Bookmark [<name>]\n"
                                    let @h=@h."\" :BookmarkToRoot <name>\n"
                                    let @h=@h."\" :RevealBookmark <name>\n"
                                    let @h=@h."\" :OpenBookmark <name>\n"
                                    let @h=@h."\" :ClearBookmarks [<names>]\n"
                                    let @h=@h."\" :ClearAllBookmarks\n"
                                    silent! put h
                                elseif !self.isMinimal()
    2              0.000013         let @h="\" Press ". g:NERDTreeMapHelp ." for help\n"
    2              0.000015         silent! put h
    2              0.000002     endif
                            
    2              0.000005     let @h = old_h

FUNCTION  neocomplete#helper#check_filetype()
Called 64 times
Total time:   0.001168
 Self time:   0.000551

count  total (s)   self (s)
   64   0.001147   0.000530   return !empty(filter(neocomplete#context_filetype#filetypes(), 'get(a:dictionary, v:val, 0)'))

FUNCTION  neocomplete#mappings#auto_complete()
Called 6 times
Total time:   0.122169
 Self time:   0.005744

count  total (s)   self (s)
    6   0.000061   0.000024   let neocomplete = neocomplete#get_current_neocomplete()
    6   0.000455   0.000020   let cur_text = neocomplete#get_cur_text(1)
    6   0.000086   0.000023   let complete_pos = neocomplete#complete#_get_complete_pos( neocomplete.complete_sources)
    6              0.000012   let base = cur_text[complete_pos :]
                            
    6   0.116373   0.001068   let neocomplete.candidates = neocomplete#complete#_get_words( neocomplete.complete_sources, complete_pos, base)
    6              0.000013   let neocomplete.complete_str = base
    6              0.000011   if empty(neocomplete.candidates)
                                return ''
                              endif
                            
                              " Start auto complete.
    6   0.005116   0.004531   call complete(complete_pos+1, neocomplete.candidates)
    6              0.000011   return ''

FUNCTION  442()
Called 3 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
                              " Filters too long word.
    3              0.000060   call filter(a:context.candidates, 'len(v:val.word) < g:neocomplete#sources#buffer#max_keyword_width')

FUNCTION  443()
Called 3 times
Total time:   0.002344
 Self time:   0.000764

count  total (s)   self (s)
    3   0.001223   0.000022   call s:check_async_cache(a:context)
                            
    3              0.000006   let keyword_list = []
   36   0.000422   0.000043   for source in s:get_sources_list(a:context)
   33              0.000650     let keyword_list += source.words
   33              0.000020   endfor
    3              0.000003   return keyword_list

FUNCTION  444()
Called 9 times
Total time:   0.008390
 Self time:   0.008390

count  total (s)   self (s)
    9              0.000007   lua << EOF
                            do
                              local candidates = vim.eval('a:context.candidates')
                              local t = {}
                              local input = string.lower(vim.eval('a:context.input'))
                              for i = 1, #candidates do
                                t[i] = candidates[i-1]
                                local ti = t[i]
                            
                                -- Match position.
                                ti.neocomplete__match = select(1, string.find(
                                    string.lower(ti.word), input, 1, true))
                                if ti.neocomplete__match == nil then
                                  ti.neocomplete__match = string.len(ti.word)
                                end
                            
                                if ti.rank == nil then
                                  ti.rank = 0
                                end
                              end
                              table.sort(t, function(a, b)
                                    return (a.rank == b.rank) and (a.neocomplete__match
                                        < b.neocomplete__match) or (a.rank > b.rank)
                                  end)
                              for i = 0, #candidates-1 do
                                candidates[i] = t[i+1]
                              end
                            end
                            EOF
    9              0.000017   return a:context.candidates

FUNCTION  446()
Called 9 times
Total time:   0.093658
 Self time:   0.021789

count  total (s)   self (s)
    9   0.000640   0.000088   let next = matchstr(getline('.')[ len(neocomplete#helper#get_cur_text()) :], '^\S\+')
    9              0.000010   if next == ''
                                return a:context.candidates
                              endif
                            
    9              0.000009   let candidates = []
 1183              0.000955   for candidate in a:context.candidates
 1174   0.064771   0.004930     let overlapped_len = neocomplete#filters#converter_remove_overlap#length(candidate.word, next)
                            
 1174              0.001175     if overlapped_len > 0
                                  if !has_key(candidate, 'abbr')
                                    let candidate.abbr = candidate.word
                                  endif
                            
                                  let candidate.word = candidate.word[: -overlapped_len-1]
                                  call add(candidates, candidate)
                                elseif !neocomplete#is_auto_complete()
 1174              0.002096       call add(candidates, candidate)
 1174              0.000612     endif
 1174              0.000650   endfor
                            
    9              0.000014   if empty(candidates)
                                return a:context.candidates
                              endif
                            
    9              0.000905   let candidates = filter(candidates, 'v:val.word !=# a:context.complete_str')
                            
    9              0.000009   return candidates

FUNCTION  gitgutter#utility#file_relative_to_repo_root()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000004   let file_path_relative_to_repo_root = getbufvar(s:bufnr, 'gitgutter_repo_relative_path')
    1              0.000002   if empty(file_path_relative_to_repo_root)
                                let dir_path_relative_to_repo_root = gitgutter#utility#system(gitgutter#utility#command_in_directory_of_file('git rev-parse --show-prefix'))
                                let dir_path_relative_to_repo_root = gitgutter#utility#strip_trailing_new_line(dir_path_relative_to_repo_root)
                                let file_path_relative_to_repo_root = dir_path_relative_to_repo_root . gitgutter#utility#filename()
                                call setbufvar(s:bufnr, 'gitgutter_repo_relative_path', file_path_relative_to_repo_root)
                              endif
    1              0.000001   return file_path_relative_to_repo_root

FUNCTION  451()
Called 3 times
Total time:   0.000188
 Self time:   0.000163

count  total (s)   self (s)
    3              0.000005   let list = []
                            
    9              0.000013   for ft in a:context.filetypes
    6              0.000021     if !has_key(s:dictionary_cache, ft)
                                  call s:make_cache(ft)
                                endif
    6   0.000063   0.000038     call neocomplete#cache#check_cache( 'dictionary_cache', ft, s:async_dictionary_list, s:dictionary_cache, 1)
                            
    6              0.000021     let list += get(s:dictionary_cache, ft, [])
    6              0.000005   endfor
                            
    3              0.000003   return list

FUNCTION  448()
Called 9 times
Total time:   0.001087
 Self time:   0.001087

count  total (s)   self (s)
    9              0.000011   if g:neocomplete#max_keyword_width < 0
                                return a:context.candidates
                              endif
                            
    9              0.000007   lua << EOF
                            do
                              local candidates = vim.eval('a:context.candidates')
                              local max = vim.eval('g:neocomplete#max_keyword_width')
                              for i = 0, #candidates-1 do
                                local abbr = candidates[i].abbr == nil and
                                  candidates[i].word or candidates[i].abbr
                                if string.len(abbr) > max then
                                  vim.command("let a:context.candidates[".. i .."].abbr = neocomplete#util#truncate_smart("..
                                          "get(a:context.candidates[".. i .."], 'abbr', " ..
                                          "a:context.candidates[".. i .."].word), g:neocomplete#max_keyword_width," ..
                                          "g:neocomplete#max_keyword_width/2, '..')")
                                end
                              end
                            end
                            EOF
                            
    9              0.000011   return a:context.candidates

FUNCTION  <SNR>82_BufWritePostHook()
Called 1 time
Total time:   0.228266
 Self time:   0.000039

count  total (s)   self (s)
    1   0.000042   0.000023     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWritePost, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))))
    1   0.228222   0.000014     call s:UpdateErrors(1, [])

FUNCTION  <SNR>213_check_old_cache()
Called 1 time
Total time:   0.000799
 Self time:   0.000719

count  total (s)   self (s)
                              " Check old cache file.
    1   0.000087   0.000007   let cache_name = s:_encode_name(a:cache_dir, a:filename)
    1              0.000012   let ret = getftime(cache_name) == -1 || getftime(cache_name) <= getftime(a:filename)
    1              0.000010   if ret && filereadable(cache_name)
                                " Delete old cache.
    1              0.000681     call delete(cache_name)
    1              0.000002   endif
                            
    1              0.000002   return ret

FUNCTION  <SNR>212_search_vim_path()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000005   if exists('s:vim_path')
    1              0.000001     return s:vim_path
                              endif
                            
                              let paths = vimproc#get_command_name(v:progname, $PATH, -1)
                              if empty(paths)
                                if has('gui_macvim')
                                  " MacVim check.
                                  if !executable('/Applications/MacVim.app/Contents/MacOS/Vim')
                                    call neocomplete#print_error( 'You installed MacVim in not default directory!'. ' You must add MacVim installed path in $PATH.')
                                    let g:neocomplete#use_vimproc = 0
                                    return ''
                                  endif
                            
                                  let s:vim_path = '/Applications/MacVim.app/Contents/MacOS/Vim'
                                else
                                  call neocomplete#print_error( printf('Vim path : "%s" is not found.'.        ' You must add "%s" installed path in $PATH.',        v:progname, v:progname))
                                  let g:neocomplete#use_vimproc = 0
                                  return ''
                                endif
                              else
                                let base_path = neocomplete#util#substitute_path_separator( fnamemodify(paths[0], ':p:h'))
                            
                                let s:vim_path = base_path . '/vim'
                            
                                if !executable(s:vim_path) && neocomplete#util#is_mac()
                                  " Note: Search "Vim" instead of vim.
                                  let s:vim_path = base_path. '/Vim'
                                endif
                              endif
                            
                              return s:vim_path

FUNCTION  neocomplete#complete#_get_results()
Called 10 times
Total time:   0.053093
 Self time:   0.000566

count  total (s)   self (s)
   10   0.000078   0.000038   call neocomplete#print_debug('start get_complete_sources')
                            
   10   0.000093   0.000033   let neocomplete = neocomplete#get_current_neocomplete()
   10              0.000056   let neocomplete.start_time = reltime()
                            
                              " Comment check.
   10   0.000398   0.000052   let neocomplete.within_comment = neocomplete#helper#get_syn_name(1) ==# 'Comment'
                            
   10   0.014439   0.000102   let complete_sources = call( 'neocomplete#complete#_set_results_pos', [a:cur_text] + a:000)
   10              0.000017   if empty(complete_sources)
    4   0.000031   0.000015     call neocomplete#print_debug('Skipped.')
    4              0.000004     return []
                              endif
                            
    6   0.000081   0.000018   if neocomplete#is_auto_complete()
    6   0.000129   0.000039     let complete_pos = neocomplete#complete#_get_complete_pos(complete_sources)
    6   0.000136   0.000032     call neocomplete#complete#_set_previous_position(a:cur_text, complete_pos)
    6              0.000005   endif
                            
    6   0.037512   0.000041   call neocomplete#complete#_set_results_words(complete_sources)
                            
    6              0.000046   return filter(copy(complete_sources), '!empty(v:val.neocomplete__context.candidates)')

FUNCTION  <SNR>171_exists_current_source()
Called 6 times
Total time:   0.000186
 Self time:   0.000056

count  total (s)   self (s)
    6   0.000182   0.000052   return has_key(s:buffer_sources, bufnr('%')) && !s:check_changed_buffer(bufnr('%'))

FUNCTION  241()
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000005     return self._showBookmarks

FUNCTION  242()
Called 294 times
Total time:   0.000392
 Self time:   0.000392

count  total (s)   self (s)
  294              0.000296     return self._showFiles

FUNCTION  244()
Called 350 times
Total time:   0.000518
 Self time:   0.000518

count  total (s)   self (s)
  350              0.000404     return self._showHidden

FUNCTION  247()
Called 354 times
Total time:   0.000530
 Self time:   0.000530

count  total (s)   self (s)
  354              0.000412     return self._ignoreEnabled == 1

FUNCTION  248()
Called 6 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    6              0.000010     return g:NERDTreeMinimalUI

FUNCTION  gitgutter#utility#has_unsaved_changes()
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000011   return getbufvar(s:bufnr, "&mod")

FUNCTION  452()
Called 10 times
Total time:   0.001405
 Self time:   0.000381

count  total (s)   self (s)
   10              0.000022   let filetype = a:context.filetype
   10              0.000032   if filetype ==# 'vimshell' || filetype ==# 'unite' || filetype ==# 'int-ssh'
                                return -1
                              endif
                            
                              " Filename pattern.
   10   0.000526   0.000058   let pattern = neocomplete#get_keyword_pattern_end('filename', self.name)
   10   0.000525   0.000088   let [complete_pos, complete_str] = neocomplete#helper#match_word(a:context.input, pattern)
                            
   10   0.000236   0.000117   if (complete_str =~ '//' || complete_str == '/' || (neocomplete#is_auto_complete() &&    (complete_str !~ '/' || len(complete_str) <          g:neocomplete#auto_completion_start_length ||     complete_str =~#          '\\[^ ;*?[]"={}'']\|\.\.\+$\|/c\%[ygdrive/]$')))
                                " Not filename pattern.
   10              0.000008     return -1
                              endif
                            
                              if complete_str =~ '/'
                                let complete_pos += strridx(complete_str, '/') + 1
                              endif
                            
                              return complete_pos

FUNCTION  457()
Called 2 times
Total time:   0.000465
 Self time:   0.000103

count  total (s)   self (s)
                              " Check member prefix pattern.
    2              0.000004   let filetype = a:context.filetype
    2              0.000020   let prefix = get(g:neocomplete#sources#member#prefix_patterns, filetype, get(g:neocomplete#sources#member#prefix_patterns, '_', ''))
    2              0.000003   if prefix == ''
                                return []
                              endif
                            
    2   0.000046   0.000020   call neocomplete#sources#member#remake_cache(filetype)
                            
    2   0.000041   0.000031   let var_name = matchstr(a:context.input, s:get_member_pattern(filetype) . '\m\%(' . prefix . '\m\)\ze\w*$')
    2              0.000002   if var_name == ''
                                return []
                              endif
                            
    2   0.000338   0.000012   return s:get_member_list(a:context, a:context.input, var_name)

FUNCTION  459()
Called 7 times
Total time:   0.002520
 Self time:   0.000249

count  total (s)   self (s)
    7   0.002397   0.000202   let a:context.source__complete_results = s:set_complete_results_pos(   s:get_omni_funcs(a:context.filetype), a:context.input)
                            
    7   0.000112   0.000036   return s:get_complete_pos(a:context.source__complete_results)

FUNCTION  neocomplete#complete#_get_words()
Called 6 times
Total time:   0.115305
 Self time:   0.006562

count  total (s)   self (s)
    6   0.000171   0.000025   let frequencies = neocomplete#variables#get_frequencies()
    6              0.000016   if exists('*neocomplete#sources#buffer#get_frequencies')
    6   0.000202   0.000169     let frequencies = extend(copy( neocomplete#sources#buffer#get_frequencies()), frequencies)
    6              0.000004   endif
                            
                              " Append prefix.
    6              0.000007   let candidates = []
    6              0.000006   let len_words = 0
   13   0.002196   0.002174   for source in sort(filter(deepcopy(a:sources), '!empty(v:val.neocomplete__context.candidates)'),  's:compare_source_rank')
    9              0.000014     let context = source.neocomplete__context
    9              0.000515     let words = type(context.candidates[0]) == type('') ? map(copy(context.candidates), "{'word': v:val}") : deepcopy(context.candidates)
    9              0.000096     let context.candidates = words
                            
    9   0.000452   0.000055     call neocomplete#helper#call_hook( source, 'on_post_filter', {})
                            
    9              0.000012     if context.complete_pos > a:complete_pos
                                  let prefix = a:complete_str[: context.complete_pos                            - a:complete_pos - 1]
                            
                                  " Fix complete position.
                                  let context.complete_pos = a:complete_pos
                                  let context.complete_str = prefix
                            
                                  for candidate in words
                                    let candidate.word = prefix . candidate.word
                                  endfor
                                endif
                            
    9              0.000161     lua << EOF
                                do
                                  local frequencies = vim.eval('frequencies')
                                  local candidates = vim.eval('words')
                                  for i = 0, #candidates-1 do
                                    if frequencies[candidates[i].word] ~= nil then
                                      candidates[i].rank = frequencies[candidates[i].word]
                                    end
                                  end
                                end
                            EOF
                            
    9   0.008726   0.000047     let words = neocomplete#helper#call_filters( source.neocomplete__sorters, source, {})
    9              0.000013     if empty(words)
                                  continue
                                endif
                            
    9              0.000009     if source.max_candidates > 0
                                  let words = words[: len(source.max_candidates)-1]
                                endif
                            
                                " Set default menu.
    9              0.000030     if !has_key(words[0], 'menu') || words[0].menu !~ '^\[.*\]'
    9   0.000997   0.000048       call s:set_default_menu(words, source)
    9              0.000005     endif
                            
    9   0.098058   0.000048     let words = neocomplete#helper#call_filters( source.neocomplete__converters, source, {})
                            
    9              0.000109     let candidates += words
    9              0.000017     let len_words += len(words)
                            
    9              0.000024     if g:neocomplete#max_list > 0 && len_words > g:neocomplete#max_list
    2              0.000002       break
                                endif
                            
    7   0.000284   0.000016     if neocomplete#complete_check()
                                  return []
                                endif
    7              0.000004   endfor
                            
    6              0.000740   call filter(candidates, 'v:val.word !=# a:complete_str')
                            
    6              0.000008   if g:neocomplete#max_list > 0
    6              0.000104     let candidates = candidates[: g:neocomplete#max_list]
    6              0.000003   endif
                            
                              " Check dup and set icase.
    6              0.000042   let icase = g:neocomplete#enable_ignore_case && !((g:neocomplete#enable_smart_case    || g:neocomplete#enable_camel_case) && a:complete_str =~ '\u')
    6              0.000005   if icase
  159              0.000109     for candidate in candidates
  154              0.000161       let candidate.icase = 1
  154              0.000070     endfor
    5              0.000003   endif
                            
    6   0.000255   0.000016   if neocomplete#complete_check()
                                return []
                              endif
                            
    6              0.000004   return candidates

FUNCTION  <SNR>80__normalise_filetype()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000006     let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
    1              0.000005     let ft = get(g:syntastic_filetype_map, ft, ft)
    1              0.000005     let ft = substitute(ft, '\m-', '_', 'g')
    1              0.000001     return ft

FUNCTION  SyntasticMake()
Called 1 time
Total time:   0.223535
 Self time:   0.000422

count  total (s)   self (s)
    1   0.000015   0.000006     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'SyntasticMake: called with options:', a:options)
                            
                                " save options and locale env variables {{{3
    1              0.000003     let old_local_errorformat = &l:errorformat
    1              0.000002     let old_errorformat = &errorformat
    1              0.000016     let old_cwd = getcwd()
                                " }}}3
                            
    1              0.000003     if has_key(a:options, 'errorformat')
    1              0.000013         let &errorformat = a:options['errorformat']
    1              0.000001     endif
                            
    1              0.000003     if has_key(a:options, 'cwd')
                                    execute 'lcd ' . fnameescape(a:options['cwd'])
                                endif
                            
                                " set environment variables {{{3
    1              0.000002     let env_save = {}
    1              0.000003     if has_key(a:options, 'env') && len(a:options['env'])
                                    for key in keys(a:options['env'])
                                        if key =~? '\m^[a-z_]\+$'
                                            execute 'let env_save[' . string(key) . '] = $' . key
                                            execute 'let $' . key . ' = ' . string(a:options['env'][key])
                                        endif
                                    endfor
                                endif
                                " }}}3
                            
    1   0.223070   0.000046     let err_lines = split(syntastic#util#system(a:options['makeprg']), "\n", 1)
                            
                                " restore environment variables {{{3
    1              0.000005     if len(env_save)
                                    for key in keys(env_save)
                                        execute 'let $' . key . ' = ' . string(env_save[key])
                                    endfor
                                endif
                                " }}}3
                            
    1   0.000032   0.000013     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                            
                                " Does it still make sense to go on?
    1   0.000026   0.000012     let bailout = syntastic#util#var('exit_checks') && has_key(a:options, 'returns') && index(a:options['returns'], v:shell_error) == -1
                            
    1              0.000001     if !bailout
    1              0.000002         if has_key(a:options, 'Preprocess')
                                        let err_lines = call(a:options['Preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess (external):', err_lines)
                                    elseif has_key(a:options, 'preprocess')
                                        let err_lines = call('syntastic#preprocess#' . a:options['preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess:', err_lines)
                                    endif
    1              0.000061         lgetexpr err_lines
                            
    1              0.000031         let errors = deepcopy(getloclist(0))
                            
    1              0.000002         if has_key(a:options, 'cwd')
                                        execute 'lcd ' . fnameescape(old_cwd)
                                    endif
                            
    1              0.000001         try
    1              0.000007             silent lolder
    1              0.000002         catch /\m^Vim\%((\a\+)\)\=:E380/
                                        " E380: At bottom of quickfix stack
                                        call setloclist(0, [], 'r')
                                    catch /\m^Vim\%((\a\+)\)\=:E776/
                                        " E776: No location list
                                        " do nothing
                                    endtry
    1              0.000001     else
                                    let errors = []
                                endif
                            
                                " restore options {{{3
    1              0.000013     let &errorformat = old_errorformat
    1              0.000004     let &l:errorformat = old_local_errorformat
                                " }}}3
                            
    1   0.000056   0.000050     if !s:_running_windows && (s:_os_name() =~? 'FreeBSD' || s:_os_name() =~? 'OpenBSD')
                                    call syntastic#util#redraw(g:syntastic_full_redraws)
                                endif
                            
    1              0.000000     if bailout
                                    call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                                    throw 'Syntastic: checker error'
                                endif
                            
    1   0.000013   0.000005     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'raw loclist:', errors)
                            
    1              0.000002     if has_key(a:options, 'defaults')
    1   0.000041   0.000008         call s:_add_to_errors(errors, a:options['defaults'])
    1              0.000000     endif
                            
                                " Add subtype info if present.
    1              0.000002     if has_key(a:options, 'subtype')
                                    call s:_add_to_errors(errors, { 'subtype': a:options['subtype'] })
                                endif
                            
    1              0.000002     if has_key(a:options, 'Postprocess') && !empty(a:options['Postprocess'])
                                    for rule in a:options['Postprocess']
                                        let errors = call(rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess (external):', errors)
                                elseif has_key(a:options, 'postprocess') && !empty(a:options['postprocess'])
                                    for rule in a:options['postprocess']
                                        let errors = call('syntastic#postprocess#' . rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess:', errors)
                                endif
                            
    1              0.000001     return errors

FUNCTION  <SNR>211_set_default_menu()
Called 9 times
Total time:   0.000949
 Self time:   0.000949

count  total (s)   self (s)
    9              0.000009   lua << EOF
                              do
                                local candidates = vim.eval('a:words')
                                local mark = vim.eval('a:source.mark') .. ' '
                                for i = 0, #candidates-1 do
                                  candidates[i].menu = mark .. (candidates[i].menu ~= nil and
                                                       candidates[i].menu or '')
                                end
                              end
                            EOF

FUNCTION  255()
Called 2 times
Total time:   0.055703
 Self time:   0.000578

count  total (s)   self (s)
    2              0.000020     setlocal modifiable
                            
                                "remember the top line of the buffer and the current line so we can
                                "restore the view exactly how it was
    2              0.000007     let curLine = line(".")
    2              0.000005     let curCol = col(".")
    2              0.000011     let topLine = line("w0")
                            
                                "delete all lines in the buffer (being careful not to clobber a register)
    2              0.000150     silent 1,$delete _
                            
    2   0.000317   0.000013     call self._dumpHelp()
                            
                                "delete the blank line before the help and add one after it
    2   0.000009   0.000006     if !self.isMinimal()
    2              0.000013         call setline(line(".")+1, "")
    2              0.000008         call cursor(line(".")+1, col("."))
    2              0.000001     endif
                            
    2   0.000016   0.000009     if self.getShowBookmarks()
                                    call self._renderBookmarks()
                                endif
                            
                                "add the 'up a dir' line
    2   0.000008   0.000006     if !self.isMinimal()
    2   0.000027   0.000022         call setline(line(".")+1, s:UI.UpDirLine())
    2              0.000007         call cursor(line(".")+1, col("."))
    2              0.000002     endif
                            
                                "draw the header line
    2   0.000204   0.000016     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
    2              0.000011     call setline(line(".")+1, header)
    2              0.000007     call cursor(line(".")+1, col("."))
                            
                                "draw the tree
    2              0.000004     let old_o = @o
    2   0.054682   0.000066     let @o = self.nerdtree.root.renderToString()
    2              0.000041     silent put o
    2              0.000012     let @o = old_o
                            
                                "delete the blank line at the top of the buffer
    2              0.000014     silent 1,1delete _
                            
                                "restore the view
    2              0.000005     let old_scrolloff=&scrolloff
    2              0.000021     let &scrolloff=0
    2              0.000005     call cursor(topLine, 1)
    2              0.000034     normal! zt
    2              0.000005     call cursor(curLine, curCol)
    2              0.000007     let &scrolloff = old_scrolloff
                            
    2              0.000009     setlocal nomodifiable

FUNCTION  gitgutter#hunk#reset()
Called 4 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    4              0.000045   let s:summary = [0, 0, 0]

FUNCTION  <SNR>181_make_cache_current_buffer()
Called 7 times
Total time:   0.004609
 Self time:   0.000205

count  total (s)   self (s)
    7   0.000414   0.000035   let filetype = neocomplete#get_context_filetype(1)
                            
    7              0.000027   if !has_key(s:member_sources, bufnr('%'))
                                call s:initialize_source(bufnr('%'), filetype)
                              endif
                            
    7   0.004132   0.000107   call s:make_cache_lines(bufnr('%'), filetype, getline(a:start, a:end))

FUNCTION  <SNR>116_get_syn()
Called 7664 times
Total time:   0.248770
 Self time:   0.248770

count  total (s)   self (s)
                              " need to pass in mode, known to break on 7.3.547
 7664              0.024580   let mode = has('gui_running') ? 'gui' : 'cterm'
 7664              0.099606   let color = synIDattr(synIDtrans(hlID(a:group)), a:what, mode)
 7664              0.014228   if empty(color) || color == -1
 2520              0.030774     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, mode)
 2520              0.001578   endif
 7664              0.012326   if empty(color) || color == -1
                                if has('gui_running')
                                  let color = a:what ==# 'fg' ? '#000000' : '#FFFFFF'
                                else
                                  let color = a:what ==# 'fg' ? 0 : 1
                                endif
                              endif
 7664              0.005916   return color

FUNCTION  460()
Called 2 times
Total time:   0.020056
 Self time:   0.000175

count  total (s)   self (s)
    2   0.020054   0.000173   return s:get_candidates( s:set_complete_results_words(  a:context.source__complete_results),  a:context.complete_pos, a:context.complete_str)

FUNCTION  gitgutter#utility#exists_file()
Called 4 times
Total time:   0.000104
 Self time:   0.000104

count  total (s)   self (s)
    4              0.000101   return filereadable(s:file)

FUNCTION  463()
Called 3 times
Total time:   0.000198
 Self time:   0.000096

count  total (s)   self (s)
    3              0.000019   if !has_key(s:async_tags_list, bufnr('%')) && !has_key(s:tags_list, bufnr('%'))
                                call neocomplete#sources#tag#make_cache(0)
                              endif
                            
    3   0.000043   0.000011   if neocomplete#within_comment()
                                return []
                              endif
                            
    3   0.000098   0.000028   call neocomplete#cache#check_cache( 'tags_cache', bufnr('%'), s:async_tags_list, s:tags_list, 0)
                            
    3              0.000016   return copy(get(s:tags_list, bufnr('%'), []))

FUNCTION  fugitive#reload_status()
Called 1 time
Total time:   0.000181
 Self time:   0.000181

count  total (s)   self (s)
    1              0.000007   if exists('s:reloading_status')
                                return
                              endif
    1              0.000002   try
    1              0.000003     let s:reloading_status = 1
    1              0.000002     let mytab = tabpagenr()
    3              0.000007     for tab in [mytab] + range(1,tabpagenr('$'))
    6              0.000024       for winnr in range(1,tabpagewinnr(tab,'$'))
    4              0.000026         if getbufvar(tabpagebuflist(tab)[winnr-1],'fugitive_type') ==# 'index'
                                      execute 'tabnext '.tab
                                      if winnr != winnr()
                                        execute winnr.'wincmd w'
                                        let restorewinnr = 1
                                      endif
                                      try
                                        if !&modified
                                          call s:BufReadIndex()
                                        endif
                                      finally
                                        if exists('restorewinnr')
                                          wincmd p
                                        endif
                                        execute 'tabnext '.mytab
                                      endtry
                                    endif
    4              0.000003       endfor
    2              0.000001     endfor
    1              0.000001   finally
    1              0.000001     unlet! s:reloading_status
    1              0.000000   endtry

FUNCTION  <SNR>119_should_change_group()
Called 54 times
Total time:   0.004124
 Self time:   0.000426

count  total (s)   self (s)
   54              0.000105   if a:group1 == a:group2
   36              0.000024     return 0
                              endif
   18   0.002085   0.000078   let color1 = airline#highlighter#get_highlight(a:group1)
   18   0.001757   0.000066   let color2 = airline#highlighter#get_highlight(a:group2)
   18              0.000040   if has('gui_running')
   18              0.000055     return color1[1] != color2[1] || color1[0] != color2[0]
                              else
                                return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  <SNR>56_NERDTreeCacheDirtyDir()
Called 19 times
Total time:   0.001824
 Self time:   0.001508

count  total (s)   self (s)
                                " cache dirty dir
   19   0.000424   0.000108     let l:dirtyPath = s:NERDTreeTrimDoubleQuotes(a:pathStr)
   19              0.000083     if l:dirtyPath =~# '\.\./.*'
                                    return
                                endif
   19              0.000240     let l:dirtyPath = substitute(l:dirtyPath, '/[^/]*$', '/', '')
   35              0.000523     while l:dirtyPath =~# '.\+/.*' && has_key(b:NERDTreeCachedGitDirtyDir, fnameescape(l:dirtyPath)) == 0
   16              0.000140         let b:NERDTreeCachedGitDirtyDir[fnameescape(l:dirtyPath)] = 'Dirty'
   16              0.000189         let l:dirtyPath = substitute(l:dirtyPath, '/[^/]*/$', '/', '')
   16              0.000019     endwhile

FUNCTION  vimproc#analyze_shebang()
Called 1 time
Total time:   0.000087
 Self time:   0.000084

count  total (s)   self (s)
    1   0.000023   0.000021   if !filereadable(a:filename) || getfsize(a:filename) > 100000 || (vimproc#util#is_windows() && '.'.fnamemodify(a:filename, ':e') !~?   '^'.substitute($PATHEXT, ';', '$\\|^', 'g').'$')
                                  " Maybe a binary file.
                                return [a:filename]
                              endif
                            
    1              0.000015   let lines = readfile(a:filename, '', 1)
    1              0.000008   if empty(lines) || lines[0] !~ '^#!.\+'
                                " Shebang not found.
                                return [a:filename]
                              endif
                            
                              " Get shebang line.
    1              0.000011   let shebang = split(matchstr(lines[0], '^#!\zs.\+'))
                            
                              " Convert command name.
    1   0.000005   0.000004   if vimproc#util#is_windows() && shebang[0] =~ '^/'
                                let shebang[0] = vimproc#get_command_name( fnamemodify(shebang[0], ':t'))
                              endif
                            
    1              0.000005   return shebang + [a:filename]

FUNCTION  gitgutter#utility#directory_of_file()
Called 3 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    3              0.000009   return fnamemodify(s:file, ':h')

FUNCTION  <SNR>116_exec_separator()
Called 1898 times
Total time:   0.542017
 Self time:   0.052066

count  total (s)   self (s)
 1898   0.233459   0.007981   let l:from = airline#themes#get_highlight(a:from.a:suffix)
 1898   0.197791   0.007322   let l:to = airline#themes#get_highlight(a:to.a:suffix)
 1898              0.005420   let group = a:from.'_to_'.a:to.a:suffix
 1898              0.001668   if a:inverse
  446              0.001672     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
  446              0.000268   else
 1452              0.005450     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
 1452              0.000853   endif
 1898              0.007154   let a:dict[group] = colors
 1898   0.081325   0.007321   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>157_is_directory_exist()
Called 1 time
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    1              0.000044   let ignore = !empty(g:neomru#directory_mru_ignore_pattern) && a:path =~ g:neomru#directory_mru_ignore_pattern
    1              0.000007   return !ignore && (isdirectory(a:path) || a:path =~ '^\h\w\+:')

FUNCTION  gitgutter#utility#is_active()
Called 4 times
Total time:   0.000328
 Self time:   0.000061

count  total (s)   self (s)
    4   0.000320   0.000053   return g:gitgutter_enabled && gitgutter#utility#exists_file() && gitgutter#utility#not_git_dir() && !gitgutter#utility#help_file()

FUNCTION  263()
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    2              0.000004     return '.. (up a dir)'

FUNCTION  266()
Called 72 times
Total time:   0.080694
 Self time:   0.001587

count  total (s)   self (s)
   72   0.001201   0.000405     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                            
  144   0.001312   0.000387     for listener in s:Notifier.GetListenersForEvent(a:event)
   72   0.077751   0.000365         call {listener}(event)
   72              0.000062     endfor

FUNCTION  267()
Called 72 times
Total time:   0.000409
 Self time:   0.000409

count  total (s)   self (s)
   72              0.000189     if !exists("s:refreshListenersMap")
                                    let s:refreshListenersMap = {}
                                endif
   72              0.000073     return s:refreshListenersMap

FUNCTION  268()
Called 72 times
Total time:   0.000925
 Self time:   0.000516

count  total (s)   self (s)
   72   0.000689   0.000280     let listenersMap = s:Notifier.GetListenersMap()
   72              0.000202     return get(listenersMap, a:name, [])

FUNCTION  gitgutter#utility#save_last_seen_change()
Called 3 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    3              0.000026   call setbufvar(s:bufnr, 'gitgutter_last_tick', getbufvar(s:bufnr, 'changedtick'))

FUNCTION  neocomplete#helper#call_hook()
Called 9 times
Total time:   0.000397
 Self time:   0.000307

count  total (s)   self (s)
   18   0.000072   0.000045   for source in neocomplete#util#convert2list(a:sources)
    9              0.000009     try
    9              0.000021       if has_key(source.hooks, a:hook_name)
    3   0.000081   0.000018         call call(source.hooks[a:hook_name], [extend(source.neocomplete__context, a:context)], source.hooks)
    3              0.000001       endif
    9              0.000006     catch
                                  call neocomplete#print_error(v:throwpoint)
                                  call neocomplete#print_error(v:exception)
                                  call neocomplete#print_error( 'Error occurred in calling hook "' . a:hook_name . '"!')
                                  call neocomplete#print_error( 'Source name is ' . source.name)
                                endtry
    9              0.000006   endfor

FUNCTION  neocomplete#handler#_on_complete_done()
Called 6 times
Total time:   0.002467
 Self time:   0.000614

count  total (s)   self (s)
    6   0.000151   0.000051   let neocomplete = neocomplete#get_current_neocomplete()
                            
    6              0.000018   if neocomplete.event !=# 'mapping'
                                " Check delimiter pattern.
    6              0.000013     let is_delimiter = 0
    6   0.000155   0.000039     let filetype = neocomplete#get_context_filetype()
    6   0.000856   0.000031     let cur_text = neocomplete#get_cur_text(1)
                            
   24              0.000074     for delimiter in ['/', '.'] + get(g:neocomplete#delimiter_patterns, filetype, [])
   18              0.000108       if stridx(cur_text, delimiter, len(cur_text) - len(delimiter)) >= 0
                                    let is_delimiter = 1
                                    break
                                  endif
   18              0.000017     endfor
                            
    6              0.000009     if !is_delimiter
    6   0.000824   0.000047       call neocomplete#mappings#close_popup()
    6              0.000005     endif
    6              0.000002   endif
                            
                              " Use v:completed_item feature.
    6              0.000025   if !exists('v:completed_item') || empty(v:completed_item)
    5              0.000003     return
                              endif
                            
    1              0.000002   let complete_str = v:completed_item.word
    1              0.000001   if complete_str == ''
                                return
                              endif
                            
    1   0.000039   0.000004   let frequencies = neocomplete#variables#get_frequencies()
    1              0.000002   if !has_key(frequencies, complete_str)
                                let frequencies[complete_str] = 20
                              else
    1              0.000002     let frequencies[complete_str] += 20
    1              0.000001   endif

FUNCTION  neocomplete#is_enabled()
Called 76 times
Total time:   0.000566
 Self time:   0.000372

count  total (s)   self (s)
   76   0.000515   0.000321   return neocomplete#init#is_enabled()

FUNCTION  neocomplete#is_locked()
Called 19 times
Total time:   0.000733
 Self time:   0.000136

count  total (s)   self (s)
   19   0.000720   0.000123   return neocomplete#is_cache_disabled() || &paste || (&t_Co != '' && &t_Co < 8) || g:neocomplete#disable_auto_complete

FUNCTION  <SNR>167_substitute_path_separator()
Called 6 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    6              0.000016   return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTION  airline#highlighter#get_highlight()
Called 3832 times
Total time:   0.397886
 Self time:   0.115338

count  total (s)   self (s)
 3832   0.142410   0.014578   let fg = s:get_syn(a:group, 'fg')
 3832   0.135703   0.014765   let bg = s:get_syn(a:group, 'bg')
 3832              0.062600   let reverse = has('gui_running') ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
 3832   0.054199   0.020421   return reverse ? s:get_array(bg, fg, a:000) : s:get_array(fg, bg, a:000)

FUNCTION  airline#extensions#syntastic#get_warnings()
Called 70 times
Total time:   0.005515
 Self time:   0.000702

count  total (s)   self (s)
   70   0.005095   0.000282   let errors = SyntasticStatuslineFlag()
   70              0.000139   if strlen(errors) > 0
                                return errors.(g:airline_symbols.space)
                              endif
   70              0.000047   return ''

FUNCTION  unite#handlers#_restore_updatetime()
Called 1 time
Total time:   0.000043
 Self time:   0.000023

count  total (s)   self (s)
    1   0.000031   0.000011   let unite = unite#get_current_unite()
                            
    1              0.000003   if !has_key(unite, 'update_time_save')
                                return
                              endif
                            
    1              0.000004   if unite.context.update_time > 0 && &updatetime < unite.update_time_save
                                let &updatetime = unite.update_time_save
                              endif

FUNCTION  AutoPairsInsert()
Called 1 time
Total time:   0.000302
 Self time:   0.000302

count  total (s)   self (s)
    1              0.000009   if !b:autopairs_enabled
                                return a:key
                              end
                            
    1              0.000010   let line = getline('.')
    1              0.000010   let pos = col('.') - 1
    1              0.000006   let before = strpart(line, 0, pos)
    1              0.000004   let after = strpart(line, pos)
    1              0.000012   let next_chars = split(after, '\zs')
    1              0.000005   let current_char = get(next_chars, 0, '')
    1              0.000004   let next_char = get(next_chars, 1, '')
    1              0.000021   let prev_chars = split(before, '\zs')
    1              0.000004   let prev_char = get(prev_chars, -1, '')
                            
    1              0.000002   let eol = 0
    1              0.000005   if col('$') -  col('.') <= 1
    1              0.000003     let eol = 1
    1              0.000001   end
                            
                              " Ignore auto close if prev character is \
    1              0.000004   if prev_char == '\'
                                return a:key
                              end
                            
                              " The key is difference open-pair, then it means only for ) ] } by default
    1              0.000005   if !has_key(b:AutoPairs, a:key)
                                let b:autopairs_saved_pair = [a:key, getpos('.')]
                            
                                " Skip the character if current character is the same as input
                                if current_char == a:key
                                  return "\<Right>"
                                end
                            
                                if !g:AutoPairsFlyMode
                                  " Skip the character if next character is space
                                  if current_char == ' ' && next_char == a:key
                                    return "\<Right>\<Right>"
                                  end
                            
                                  " Skip the character if closed pair is next character
                                  if current_char == ''
                                    if g:AutoPairsMultilineClose
                                      let next_lineno = line('.')+1
                                      let next_line = getline(nextnonblank(next_lineno))
                                      let next_char = matchstr(next_line, '\s*\zs.')
                                    else
                                      let next_char = matchstr(line, '\s*\zs.')
                                    end
                                    if next_char == a:key
                                      return "\<ESC>e^a"
                                    endif
                                  endif
                                endif
                            
                                " Fly Mode, and the key is closed-pairs, search closed-pair and jump
                                if g:AutoPairsFlyMode && has_key(b:AutoPairsClosedPairs, a:key)
                                  if search(a:key, 'W')
                                    return "\<Right>"
                                  endif
                                endif
                            
                                " Insert directly if the key is not an open key
                                return a:key
                              end
                            
    1              0.000003   let open = a:key
    1              0.000004   let close = b:AutoPairs[open]
                            
    1              0.000004   if current_char == close && open == close
                                return "\<Right>"
                              end
                            
                              " Ignore auto close ' if follows a word
                              " MUST after closed check. 'hello|'
    1              0.000008   if a:key == "'" && prev_char =~ '\v\w'
                                return a:key
                              end
                            
                              " support for ''' ``` and """
    1              0.000002   if open == close
                                " The key must be ' " `
    1              0.000006     let pprev_char = line[col('.')-3]
    1              0.000003     if pprev_char == open && prev_char == open
                                  " Double pair found
                                  return repeat(a:key, 4) . repeat("\<LEFT>", 3)
                                end
    1              0.000001   end
                            
    1              0.000003   let quotes_num = 0
                              " Ignore comment line for vim file
    1              0.000005   if &filetype == 'vim' && a:key == '"'
                                if before =~ '^\s*$'
                                  return a:key
                                end
                                if before =~ '^\s*"'
                                  let quotes_num = -1
                                end
                              end
                            
                              " Keep quote number is odd.
                              " Because quotes should be matched in the same line in most of situation
    1              0.000004   if g:AutoPairsSmartQuotes && open == close
                                " Remove \\ \" \'
    1              0.000012     let cleaned_line = substitute(line, '\v(\\.)', '', 'g')
    1              0.000003     let n = quotes_num
    1              0.000002     let pos = 0
    1              0.000002     while 1
    1              0.000005       let pos = stridx(cleaned_line, open, pos)
    1              0.000002       if pos == -1
    1              0.000003         break
                                  end
                                  let n = n + 1
                                  let pos = pos + 1
                                endwhile
    1              0.000003     if n % 2 == 1
                                  return a:key
                                endif
    1              0.000001   endif
                            
    1              0.000006   return open.close."\<Left>"

FUNCTION  270()
Called 1 time
Total time:   0.000042
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000009   0.000003     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
    1   0.000033   0.000005     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  <SNR>35_append()
Called 1 time
Total time:   0.000575
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000011   if bufnr('%') != expand('<abuf>') || a:path == ''
                                return
                              endif
                            
    1   0.000558   0.000011   call neomru#_append()

FUNCTION  273()
Called 2 times
Total time:   0.000019
 Self time:   0.000007

count  total (s)   self (s)
    2   0.000019   0.000007     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  275()
Called 1 time
Total time:   0.000077
 Self time:   0.000069

count  total (s)   self (s)
    1              0.000007     let b:syntastic_private_balloons = {}
    1              0.000003     if has('balloon_eval')
    1   0.000013   0.000005         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
    1              0.000002         unlet! b:syntastic_private_balloons
    1              0.000049         set noballooneval
    1              0.000001     endif

FUNCTION  277()
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000005     return self._filetype

FUNCTION  278()
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000002     return self._name

FUNCTION  279()
Called 2 times
Total time:   0.000067
 Self time:   0.000051

count  total (s)   self (s)
    2   0.000044   0.000028     let user_exec = expand( exists('b:syntastic_' . self._name . '_exec') ? b:syntastic_{self._name}_exec : syntastic#util#var(self._filetype . '_' . self._name . '_exec'), 1 )
                            
    2              0.000004     if user_exec !=# '' && user_exec !=# self._exec
                                    let self._exec = user_exec
                                    if has_key(self, '_available')
                                        " we have a new _exec on the block, it has to be validated
                                        call remove(self, '_available')
                                    endif
                                endif

FUNCTION  <SNR>171_check_changed_buffer()
Called 6 times
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
    6              0.000019   let source = s:buffer_sources[a:bufnr]
                            
    6              0.000018   let ft = getbufvar(a:bufnr, '&filetype')
    6              0.000008   if ft == ''
                                let ft = 'nothing'
                              endif
                            
    6              0.000021   let filename = fnamemodify(bufname(a:bufnr), ':t')
    6              0.000010   if filename == ''
                                let filename = '[No Name]'
                              endif
                            
    6              0.000020   return source.name != filename || source.filetype != ft

FUNCTION  <SNR>211_use_previous_result()
Called 79 times
Total time:   0.001206
 Self time:   0.001206

count  total (s)   self (s)
   79              0.001161   return !a:source.is_volatile && substitute(a:context.input, '\w\+$', '', '')    ==# substitute(a:context.prev_line, '\w\+$', '', '') && stridx(a:context.input, a:context.prev_line) == 0 && !empty(a:context.prev_candidates)

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 12 times
Total time:   0.001170
 Self time:   0.000326

count  total (s)   self (s)
   12              0.000026   if getbufvar(a:bufnr, '&modified')
    8              0.000068     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    8              0.000002   else
    4              0.000033     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    4              0.000003   endif
                            
   12              0.000015   if !empty(colors)
   12   0.000920   0.000076     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   12              0.000011   endif

FUNCTION  243()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000006     return self._showHelp

FUNCTION  neocomplete#util#convert2list()
Called 23 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
   23              0.000080   return type(a:expr) ==# type([]) ? a:expr : [a:expr]

FUNCTION  airline#extensions#branch#get_head()
Called 70 times
Total time:   0.001694
 Self time:   0.001343

count  total (s)   self (s)
   70   0.000572   0.000221   let head = airline#extensions#branch#head()
   70              0.000333   let empty_message = get(g:, 'airline#extensions#branch#empty_message', get(g:, 'airline_branch_empty_message', ''))
   70              0.000265   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   70              0.000440   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  gitgutter#utility#using_xolox_shell()
Called 6 times
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
    6              0.000021   if s:using_xolox_shell == -1
                                if !g:gitgutter_avoid_cmd_prompt_on_windows
                                  let s:using_xolox_shell = 0
                                " Although xolox/vim-shell works on both windows and unix we only want to use
                                " it on windows.
                                elseif has('win32') || has('win64') || has('win32unix')
                                  let s:using_xolox_shell = exists('g:xolox#misc#version') && exists('g:xolox#shell#version')
                                else
                                  let s:using_xolox_shell = 0
                                endif
                              endif
    6              0.000008   return s:using_xolox_shell

FUNCTION  fugitive#head()
Called 1 time
Total time:   0.000183
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000004   if !exists('b:git_dir')
                                return ''
                              endif
                            
    1   0.000178   0.000016   return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  281()
Called 1 time
Total time:   0.000025
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000025   0.000009     return syntastic#util#shescape(self._exec)

FUNCTION  282()
Called 1 time
Total time:   0.224239
 Self time:   0.000107

count  total (s)   self (s)
    1              0.000005     let name = self._filetype . '/' . self._name
                            
    1              0.000002     if has_key(self, '_enable')
                                    let status = syntastic#util#var(self._enable, -1)
                                    if type(status) != type(0)
                                        call syntastic#log#error('checker ' . name . ': invalid value ' . strtrans(string(status)) . ' for g:syntastic_' . self._enable . '; try 0 or 1 instead')
                                        return []
                                    endif
                                    if status < 0
                                        call syntastic#log#error('checker ' . name . ': checks disabled for security reasons; ' . 'set g:syntastic_' . self._enable . ' to 1 to override')
                                    endif
                                    if status <= 0
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' enabled but not forced')
                                        return []
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' forced')
                                    endif
                                endif
                            
    1              0.000002     try
    1   0.224071   0.000023         let list = self._locListFunc()
    1              0.000002         if self._exec !=# ''
    1   0.000014   0.000007             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' returned ' . v:shell_error)
    1              0.000000         endif
    1              0.000001     catch /\m\C^Syntastic: checker error$/
                                    let list = []
                                    if self._exec !=# ''
                                        call syntastic#log#error('checker ' . name . ' returned abnormal status ' . v:shell_error)
                                    else
                                        call syntastic#log#error('checker ' . name . ' aborted')
                                    endif
                                endtry
    1   0.000018   0.000007     call self._populateHighlightRegexes(list)
    1   0.000011   0.000005     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, name . ' raw:', list)
    1   0.000068   0.000008     call self._quietMessages(list)
    1              0.000003     return list

FUNCTION  283()
Called 1 time
Total time:   0.224339
 Self time:   0.000035

count  total (s)   self (s)
    1   0.224336   0.000032     return g:SyntasticLoclist.New(self.getLocListRaw())

FUNCTION  287()
Called 1 time
Total time:   0.000422
 Self time:   0.000057

count  total (s)   self (s)
    1              0.000004     let basename = self._filetype . '_' . self._name . '_'
                            
    1              0.000001     let parts = []
    1   0.000119   0.000017     call extend(parts, self._getOpt(a:opts, basename, 'exe', self.getExecEscaped()))
    1   0.000066   0.000007     call extend(parts, self._getOpt(a:opts, basename, 'args', ''))
    1   0.000092   0.000012     call extend(parts, self._getOpt(a:opts, basename, 'fname', syntastic#util#shexpand('%')))
    1   0.000069   0.000006     call extend(parts, self._getOpt(a:opts, basename, 'post_args', ''))
    1   0.000065   0.000004     call extend(parts, self._getOpt(a:opts, basename, 'tail', ''))
                            
    1              0.000003     return join(parts)

FUNCTION  288()
Called 2 times
Total time:   0.000090
 Self time:   0.000023

count  total (s)   self (s)
    2   0.000077   0.000010     call self.syncExec()
    2              0.000005     if !has_key(self, '_available')
                                    let self._available = self._isAvailableFunc()
                                endif
    2              0.000002     return self._available

FUNCTION  syntastic#util#shexpand()
Called 1 time
Total time:   0.000020
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000020   0.000008     return syntastic#util#shescape(a:0 ? expand(a:string, a:1) : expand(a:string, 1))

FUNCTION  airline#extensions#hunks#get_hunks()
Called 70 times
Total time:   0.007043
 Self time:   0.003442

count  total (s)   self (s)
   70              0.000182   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
   70   0.003918   0.000317   let hunks = s:get_hunks()
   70              0.000088   let string = ''
   70              0.000096   if !empty(hunks)
  280              0.000351     for i in [0, 1, 2]
  210              0.000329       if s:non_zero_only == 0 || hunks[i] > 0
  210              0.001057         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  210              0.000131       endif
  210              0.000118     endfor
   70              0.000041   endif
   70              0.000063   return string

FUNCTION  neocomplete#variables#get_frequencies()
Called 7 times
Total time:   0.000181
 Self time:   0.000112

count  total (s)   self (s)
    7              0.000016   if !exists('s:filetype_frequencies')
                                let s:filetype_frequencies = {}
                              endif
    7   0.000091   0.000022   let filetype = neocomplete#get_context_filetype()
    7              0.000017   if !has_key(s:filetype_frequencies, filetype)
                                let s:filetype_frequencies[filetype] = {}
                              endif
                            
    7              0.000015   let frequencies = s:filetype_frequencies[filetype]
                            
    7              0.000005   return frequencies

FUNCTION  gitgutter#sign#remove_dummy_sign()
Called 1 time
Total time:   0.000019
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000005   0.000003   let bufnr = gitgutter#utility#bufnr()
    1              0.000004   if getbufvar(bufnr, 'gitgutter_dummy_sign') && (a:force || !g:gitgutter_sign_column_always)
    1              0.000005     execute "sign unplace" s:dummy_sign_id "buffer=" . bufnr
    1              0.000004     call setbufvar(bufnr, 'gitgutter_dummy_sign', 0)
    1              0.000001   endif

FUNCTION  292()
Called 1 time
Total time:   0.000060
 Self time:   0.000038

count  total (s)   self (s)
                                " wildcard quiet_messages
    1   0.000014   0.000005     let quiet_filters = copy(syntastic#util#var('quiet_messages', {}))
    1              0.000003     if type(quiet_filters) != type({})
                                    call syntastic#log#warn('ignoring invalid syntastic_quiet_messages')
                                    unlet quiet_filters
                                    let quiet_filters = {}
                                endif
                            
                                " per checker quiet_messages
    1              0.000003     let name = self._filetype . '_' . self._name
    1              0.000001     try
    1   0.000013   0.000006         call extend( quiet_filters, copy(syntastic#util#var(name . '_quiet_messages', {})), 'force' )
    1              0.000000     catch /\m^Vim\%((\a\+)\)\=:E712/
                                    call syntastic#log#warn('ignoring invalid syntastic_' . name . '_quiet_messages')
                                endtry
                            
    1   0.000010   0.000004     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'quiet_messages filter:', quiet_filters)
                            
    1              0.000001     if !empty(quiet_filters)
                                    call syntastic#util#dictFilter(a:errors, quiet_filters)
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'filtered by quiet_messages:', a:errors)
                                endif

FUNCTION  293()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000002     if has_key(self, '_highlightRegexFunc')
                                    for e in a:errors
                                        if e['valid']
                                            let term = self._highlightRegexFunc(e)
                                            if term !=# ''
                                                let e['hl'] = term
                                            endif
                                        endif
                                    endfor
                                endif

FUNCTION  294()
Called 5 times
Total time:   0.000320
 Self time:   0.000138

count  total (s)   self (s)
    5              0.000009     let ret = []
    5   0.000095   0.000038     call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_before', '')) )
    5   0.000129   0.000049     call extend( ret, syntastic#util#argsescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
    5   0.000074   0.000029     call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_after', '')) )
                            
    5              0.000004     return ret

FUNCTION  296()
Called 2 times
Total time:   0.000017
 Self time:   0.000004

count  total (s)   self (s)
    2   0.000017   0.000004     return syntastic#util#var('echo_current_error')

FUNCTION  297()
Called 1 time
Total time:   0.000022
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000014   0.000004     if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
                                endif

FUNCTION  298()
Called 1 time
Total time:   0.000029
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000013   0.000005     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
    1              0.000010     autocmd! syntastic CursorMoved
    1              0.000002     unlet! b:syntastic_private_messages
    1              0.000004     let b:syntastic_private_line = -1

FUNCTION  syntastic#util#argsescape()
Called 15 times
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
   15              0.000043     if type(a:opt) == type('') && a:opt !=# ''
    3              0.000003         return [a:opt]
                                elseif type(a:opt) == type([])
                                    return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
                                endif
                            
   12              0.000011     return []

FUNCTION  456()
Called 7 times
Total time:   0.000272
 Self time:   0.000231

count  total (s)   self (s)
                              " Check member prefix pattern.
    7              0.000013   let filetype = a:context.filetype
    7              0.000040   let prefix = get(g:neocomplete#sources#member#prefix_patterns, filetype, get(g:neocomplete#sources#member#prefix_patterns, '_', ''))
    7              0.000010   if prefix == ''
                                return -1
                              endif
                            
    7   0.000074   0.000033   let member = s:get_member_pattern(filetype)
    7              0.000096   let complete_pos = matchend(a:context.input, member . '\m\%(' . prefix . '\m\)\ze\w*$')
    7              0.000008   return complete_pos

FUNCTION  <SNR>145_is_pseudo_device()
Called 2 times
Total time:   0.000026
 Self time:   0.000022

count  total (s)   self (s)
    2   0.000014   0.000010   if vimproc#util#is_windows() && (    a:filename ==# '/dev/stdin' || a:filename ==# '/dev/stdout' || a:filename ==# '/dev/stderr')
                                return 1
                              endif
                            
    2              0.000006   return a:filename == '' || a:filename ==# '/dev/clip' || a:filename ==# '/dev/quickfix'

FUNCTION  vimproc#util#systemencoding()
Called 18 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
   18              0.000022   return s:is_windows ? 'utf-8' : 'char'

FUNCTION  SyntasticStatuslineFlag()
Called 70 times
Total time:   0.004813
 Self time:   0.000490

count  total (s)   self (s)
   70   0.004766   0.000443     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  <SNR>145_vp_pgroup_close()
Called 3 times
Total time:   0.000463
 Self time:   0.000008

count  total (s)   self (s)
    3   0.000461   0.000006   call self.fd.close()

FUNCTION  vimproc#util#has_iconv()
Called 18 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
                              " On Windows, some encodings can be converted by iconv() even if
                              " libiconv.dll is not available.
   18              0.000043   return (has('iconv') || (s:is_windows && exists('*iconv')))

FUNCTION  gitgutter#diff#is_removed()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return a:from_count > 0 && a:to_count == 0

FUNCTION  <SNR>114_get_visible_buffers()
Called 6 times
Total time:   0.895745
 Self time:   0.002298

count  total (s)   self (s)
    6   0.039184   0.000038   let buffers = s:get_buffer_list()
    6              0.000011   let cur = bufnr('%')
                            
    6              0.000007   let total_width = 0
    6              0.000007   let max_width = 0
                            
  144              0.000141   for nr in buffers
  138   0.855160   0.000859     let width = len(airline#extensions#tabline#get_buffer_name(nr)) + 4
  138              0.000240     let total_width += width
  138              0.000410     let max_width = max([max_width, width])
  138              0.000084   endfor
                            
                              " only show current and surrounding buffers if there are too many buffers
    6              0.000026   let position  = index(buffers, cur)
    6              0.000018   let vimwidth = &columns
    6              0.000010   if total_width > vimwidth && position > -1
    6              0.000010     let buf_count = len(buffers)
                            
                                " determine how many buffers to show based on the longest buffer width,
                                " use one on the right side and put the rest on the left
    6              0.000008     let buf_max   = vimwidth / max_width
    6              0.000007     let buf_right = 1
    6              0.000018     let buf_left  = max([0, buf_max - buf_right])
                            
    6              0.000015     let start = max([0, position - buf_left])
    6              0.000016     let end   = min([buf_count, position + buf_right])
                            
                                " fill up available space on the right
    6              0.000006     if position < buf_left
    6              0.000009       let end += (buf_left - position)
    6              0.000003     endif
                            
                                " fill up available space on the left
    6              0.000008     if end > buf_count - 1 - buf_right
                                  let start -= max([0, buf_right - (buf_count - 1 - position)])
                                endif
                            
    6              0.000056     let buffers = eval('buffers[' . start . ':' . end . ']')
                            
    6              0.000005     if start > 0
                                  call insert(buffers, -1, 0)
                                endif
                            
    6              0.000006     if end < buf_count - 1
    6              0.000011       call add(buffers, -1)
    6              0.000004     endif
    6              0.000002   endif
                            
    6              0.000036   let g:current_visible_buffers = buffers
    6              0.000005   return buffers

FUNCTION  <SNR>145_fdopen()
Called 2 times
Total time:   0.000426
 Self time:   0.000055

count  total (s)   self (s)
    2   0.000424   0.000053   return { 'fd' : a:fd, 'eof' : 0, '__eof' : 0, 'is_valid' : 1, 'buffer' : [], 'f_close' : s:funcref(a:f_close), 'f_read' : s:funcref(a:f_read), 'f_write' : s:funcref(a:f_write), 'close' : s:funcref('close'), 'read' : s:funcref('read'), 'write' : s:funcref('write'), 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),}

FUNCTION  <SNR>213__create_hash()
Called 6 times
Total time:   0.000188
 Self time:   0.000188

count  total (s)   self (s)
    6              0.000029   if len(a:dir) + len(a:str) < 150
    6              0.000123     let hash = substitute(substitute( a:str, ':', '=-', 'g'), '[/\\]', '=+', 'g')
    6              0.000002   else
                                let hash = s:S.hash(a:str)
                              endif
                            
    6              0.000009   return hash

FUNCTION  <SNR>181_get_sources_list()
Called 2 times
Total time:   0.000233
 Self time:   0.000233

count  total (s)   self (s)
    2              0.000003   let filetypes_dict = {}
    6              0.000007   for filetype in a:context.filetypes
    4              0.000009     let filetypes_dict[filetype] = 1
    4              0.000001   endfor
                            
    2              0.000206   return values(filter(copy(s:member_sources), "has_key(filetypes_dict, v:val.filetype) || has_key(filetypes_dict, '_') || bufnr('%') == v:key || (bufname('%') ==# '[Command Line]' && bufwinnr('#') == v:key)"))

FUNCTION  <SNR>82__add_to_errors()
Called 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000003     for err in a:errors
    2              0.000004         for key in keys(a:options)
    1              0.000004             if !has_key(err, key) || empty(err[key])
    1              0.000003                 let err[key] = a:options[key]
    1              0.000002             endif
    1              0.000001         endfor
    1              0.000001     endfor
                            
    1              0.000001     return a:errors

FUNCTION  airline#extensions#tabline#default#format()
Called 442 times
Total time:   0.040497
 Self time:   0.033409

count  total (s)   self (s)
  442              0.000718   let _ = ''
                            
  442              0.001127   let name = bufname(a:bufnr)
  442              0.000727   if empty(name)
                                let _ .= '[No Name]'
                              else
  442              0.000524     if s:fnamecollapse
  442              0.024108       let _ .= substitute(fnamemodify(name, s:fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
  442              0.000443     else
                                  let _ .= fnamemodify(name, s:fmod)
                                endif
  442              0.000241   endif
                            
  442   0.009508   0.002420   return airline#extensions#tabline#default#wrap_name(a:bufnr, _)

FUNCTION  264()
Called 72 times
Total time:   0.000796
 Self time:   0.000796

count  total (s)   self (s)
   72              0.000200     let newObj = copy(self)
   72              0.000121     let newObj.nerdtree = a:nerdtree
   72              0.000113     let newObj.subject = a:subject
   72              0.000118     let newObj.action = a:action
   72              0.000111     let newObj.params = a:params
   72              0.000061     return newObj

FUNCTION  vimproc#filepath#which()
Called 1 time
Total time:   0.000053
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000052   0.000011   return s:which(a:command, a:path, a:maxcount)

FUNCTION  <SNR>183_uniq()
Called 13 times
Total time:   0.006427
 Self time:   0.000095

count  total (s)   self (s)
   13   0.006418   0.000086   return s:uniq_by(a:list, 'v:val')

FUNCTION  neocomplete#sources#buffer#get_frequencies()
Called 6 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    6              0.000029   return get(get(s:buffer_sources, bufnr('%'), {}), 'frequencies', {})

FUNCTION  neocomplete#is_auto_complete()
Called 1256 times
Total time:   0.012472
 Self time:   0.005597

count  total (s)   self (s)
 1256   0.010671   0.003796   let neocomplete = neocomplete#get_current_neocomplete()
 1256              0.001211   return neocomplete.is_auto_complete

FUNCTION  airline#builder#new()
Called 6 times
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
    6              0.000044   let builder = copy(s:prototype)
    6              0.000013   let builder._context = a:context
    6              0.000008   let builder._sections = []
                            
    6              0.000058   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    6              0.000006   return builder

FUNCTION  <SNR>116_get_array()
Called 3832 times
Total time:   0.033778
 Self time:   0.033778

count  total (s)   self (s)
 3832              0.005318   let fg = a:fg
 3832              0.003955   let bg = a:bg
 3832              0.021950   return has('gui_running') ? [ fg, bg, '', '', join(a:opts, ',') ] : [ '', '', fg, bg, join(a:opts, ',') ]

FUNCTION  gitgutter#hunk#set_hunks()
Called 3 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    3              0.000030   let s:hunks = a:hunks

FUNCTION  <SNR>171_check_async_cache()
Called 3 times
Total time:   0.001201
 Self time:   0.000283

count  total (s)   self (s)
   36   0.000483   0.000048   for source in s:get_sources_list(a:context)
   33              0.000082     if !has_key(s:async_dictionary_list, source.path)
   32              0.000027       continue
                                endif
                            
                                " Load from cache.
    1   0.000498   0.000015     let [loaded, file_cache] = neocomplete#cache#get_cache_list( 'buffer_cache', s:async_dictionary_list[source.path])
    1              0.000001     if loaded
    1              0.000033       let source.words = file_cache
    1              0.000001     endif
                            
    1              0.000004     if empty(s:async_dictionary_list[source.path])
    1              0.000005       call remove(s:async_dictionary_list, source.path)
    1              0.000001     endif
    1              0.000001   endfor

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  442   2.780866   0.006166  airline#extensions#tabline#get_buffer_name()
  448   2.773349             <SNR>114_get_buffer_list()
  107   0.944197   0.006262  airline#check_mode()
   12   0.936765   0.191731  airline#highlighter#highlight()
   38   0.915671   0.000865  airline#extensions#tabline#get()
   38   0.914806   0.002499  <SNR>114_get_buffers()
    6   0.895745   0.002298  <SNR>114_get_visible_buffers()
 1898   0.542017   0.052066  <SNR>116_exec_separator()
 3796   0.415947   0.021759  airline#themes#get_highlight()
 3832   0.397886   0.115338  airline#highlighter#get_highlight()
 7556   0.282805             airline#highlighter#exec()
 7664   0.248770             <SNR>116_get_syn()
    1   0.228266   0.000039  <SNR>82_BufWritePostHook()
    1   0.228208   0.000173  <SNR>82_UpdateErrors()
    1   0.226627   0.000298  <SNR>82_CacheErrors()
    1   0.224339   0.000035  283()
    1   0.224239   0.000107  282()
    1   0.224048   0.000063  SyntaxCheckers_javascript_jshint_GetLocList()
    1   0.223535   0.000422  SyntasticMake()
    1   0.223024   0.000261  syntastic#util#system()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  448              2.773349  <SNR>114_get_buffer_list()
 7556              0.282805  airline#highlighter#exec()
 7664              0.248770  <SNR>116_get_syn()
   12   0.936765   0.191731  airline#highlighter#highlight()
  108   0.159523   0.144361  134()
 3832   0.397886   0.115338  airline#highlighter#get_highlight()
 1174              0.059841  neocomplete#filters#converter_remove_overlap#length()
   22   0.107408   0.055140  164()
 1898   0.542017   0.052066  <SNR>116_exec_separator()
 3832              0.033778  <SNR>116_get_array()
  442   0.040497   0.033409  airline#extensions#tabline#default#format()
    9   0.093658   0.021789  446()
 3796   0.415947   0.021759  airline#themes#get_highlight()
  354   0.040507   0.014815  31()
    1   0.013554   0.013552  gitgutter#sign#add_dummy_sign()
  708   0.017338   0.013018  32()
    4              0.011747  javascriptcomplete#CompleteJS()
 1730              0.010153  neocomplete#get_current_neocomplete()
    9              0.008390  444()
  887              0.008132  26()

